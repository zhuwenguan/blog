{"posts":[{"title":"25电赛A题满分方案解析","text":"前言 博主参加2025年电赛A题——能量回馈的变流器负载试验装置，达成了题目所有指标，在此分享整个方案设计。 题目解析 1. 原题再现 设计并制作一个能量回馈的变流器负载试验装置（简称试验装置），其结构如图1 所示。变流器负载试验时，受试变流器1（DC-AC）将直流电变为交流电，其输出通过连接单元与变流器2（AC-DC）相连，变流器2 将交流电转换成直流电，并回馈至变流器1 的输入端，与直流电源共同给变流器1 供电，从而实现节能。 2. 题设要求 基本要求 变流器1 能输出f1=50Hzf_1=50Hzf1​=50Hz、线电压U1=32V±0.25VU_1=32V±0.25VU1​=32V±0.25V、额定线电流I1=2AI_1=2AI1​=2A 的三相对称正弦交流电。 在基本要求（1）的工作条件下，要求输出交流电压总谐波畸变率（THD）不大于2%。 变流器1 输出50Hz50Hz50Hz、U1=32V±0.25VU_1=32V±0.25VU1​=32V±0.25V的三相交流电，I1I_1I1​在0A~2A 间变化时，要求负载调整率SI1≤0.3%S_{I1}≤0.3\\%SI1​≤0.3%。 要求变流器1 输出交流电的频率范围为20Hz~100Hz，步进1Hz。 发挥部分 按图1 进行测试。 试验装置能实现能量回馈，要求变流器1输出电流I1I_1I1​不小于1A。 变流器1 输出50Hz50Hz50Hz、U1=32V±0.25VU_1=32V±0.25VU1​=32V±0.25V、I1=2AI_1 = 2AI1​=2A，要求直流电源输出功率Pd=IdUd越小越好。 其他。 3. 题目工程背景 从我自己的理解来看，这套题目并非空穴来风，而是有很强的工程实践意义的。三相电在生活当中常用于电机驱动，而三相逆变器、电机两个东西放到一起，最容易想到的就是新能源汽车。电动汽车的电源来自于一块大号锂电池，也就是一个直流电源。但是电动汽车的电机需要三相交流电才能驱动。因此，每一台电动汽车，本质上都是一台三相逆变器。这就与题目的变流器1——DC-AC三相逆变器相呼应。 其次题目的核心功能——“能量回馈”功能，与电动汽车的“动能回收”功能，有着丝丝缕缕的联系。电动汽车的电机在输入机械能时，也就变成了一个发电机，将机械能转变为电能。驱动电机需要三相电，电机发电得到的自然也是三相电，这就与题目中的变流器2相呼应，将三相电转变为直流电。 题目中，特别提到了“连接单元”这一模块，表面上，是连接逆变器、馈流器、电阻负载之间的连接单元，实际上，也可以指代电动汽车中，电机产生的机械能，返回到电机并发电产生电能，这一过程所使用的连接器、传动装置等。再者，题目所要求的变频功能，也对应着三相电机通过变频改变转速的功能。 总的来说，这一个题目，是新能源汽车电能变换全流程的缩影。 方案概述 三相逆变器设计 1. 硬件设计 三相逆变器拓扑结构就是三个半桥顶底相连，中心引出三相电。通过电感和电容组成的LC滤波器将开关过程产生的谐波过滤掉，保留50Hz的工频交流电。 我所设计的三相逆变器采用三个IR2104半桥驱动芯片驱动六颗MOSFET，每颗IR2104都能自动产生两路互补PWM波形，单片机只需要给出高侧MOS管PWM波形，IR2104自动将其反向并添加死区，给到下管。类似于IR2104的芯片都可以使用，能够有效节省单片机的PWM资源。不过对于STM32的TIM1和TIM8来说并不重要，其具有反相输出功能，不需要额外工作。 2. SPWM原理 SPWM传统上是用一个正弦波与三角波进行比较，得到一系列占空比变化的PWM波形。正弦波幅值与三角波幅值的比值即为调制比。 这里分析一下调制比与SPWM的关系，进而得到调制比与输出电压的关系。首先，如果调制比很高，比如2.0，那么意味着正弦波有很长一段时间始终高于三角波，就会导致输出一段时间的高电平，而且占空比整体都比较高。如果调制比很低，那么正弦波的幅值永远低于三角波，则不会出现某一个PWM周期的占空比为100%，占空比整体都比较低。 如果PWM占空比高，按照DC-DC的经验，输出电压就会高。结合刚才的分析，调制比高的时候，占空比整体高，则输出电压高，调制比低，则输出电压低。因此，我们通过调整SPWM的调制比，就可以改变输出电压的幅值。 3. 电压计算 考虑调制比为1.0的一列SPWM波，忽略开关损耗、导通损耗，假设LC滤波器为理想滤波器。 每一半桥的输出电压幅值 Um=12UdU_m=\\frac{1}{2}U_d Um​=21​Ud​ 其中UmU_mUm​为相电压幅值，UdU_dUd​为直流电压。 取其中两相电压做差，有以下关系： uA=Um∗cos⁡(2πft)uB=Um∗cos⁡(2πft+23π)uAB=uA−uB=3Um∗cos⁡(2πft+16π)\\begin{aligned} u_A=&amp;U_m*\\cos(2\\pi ft)\\\\ u_B=&amp;U_m*\\cos(2\\pi ft + \\frac{2}{3}\\pi)\\\\ u_{AB}=&amp;u_A-u_B\\\\ =&amp;\\sqrt{3}U_m*\\cos(2\\pi ft+\\frac{1}{6}\\pi) \\end{aligned} uA​=uB​=uAB​==​Um​∗cos(2πft)Um​∗cos(2πft+32​π)uA​−uB​3​Um​∗cos(2πft+61​π)​ 其中uAu_AuA​、uBu_BuB​为相电压，uABu_{AB}uAB​为线电压。 小写uuu为瞬时值，大写UUU为有效值，下同。 因此，线电压uABu_{AB}uAB​的电压幅值为相电压幅值的3\\sqrt{3}3​倍，即直流电压的32\\frac{\\sqrt{3}}{2}23​​倍。进而，线电压有效值 UAB=64Ud≈0.6123Ud\\boxed{U_{AB}=\\frac{\\sqrt{6}}{4}U_d\\approx0.6123U_d} UAB​=46​​Ud​≈0.6123Ud​​ 推导过程参考此处 有了这个数据，就可以推导出直流电源供电电压。题目没有规定这一电压，可以按照我们的需求自由选择。32V线电压逆推出直流电压为52.26V。为了保险，同时也考虑到各处带来的损耗，我们最终选择58V直流电压输入。 4. 软件设计 本方案采用STM32F429ZIT6 Dicovery开发板为主控。逆变器软件主要功能包括： SPWM波形产生 输出电压、电流采样 PID闭环调控 可控变频 下面分别解析各个功能如何产生。 SPWM波形产生 传统方法产生SPWM波，是将三角波与正弦波进行比较，得到高低电平。这个方法应用在单片机上并不合适。更简单高效的方法是，通过数学计算，得出每一个周期的SPWM占空比，存储到内存里面，实时更新占空比即可。 下面推导SPWM的计算公式。本质上，SPWM就是一个占空比随正弦变化规律变化的PWM波形。当时间位于T4\\frac{T}{4}4T​的整数倍时，正弦波幅度为1，对应SPWM占空比为100%，反之，当时间位于3T4\\frac{3T}{4}43T​的整数倍时，正弦波幅度为-1，对应占空比为0%。通过这个关系，可以得到如下公式 duty=k∗12(cos⁡(2πft+ϕ0)+1)duty=k*\\frac{1}{2}(\\cos(2\\pi ft+\\phi_0)+1) duty=k∗21​(cos(2πft+ϕ0​)+1) 其中，kkk为调制比。验证一下，如果k=2k=2k=2，则dutydutyduty在一段时间内大于1，且上升较快，占空比整体较高，反之亦然。与先前的分析一致。 单片机内，很难对当前时间进行精准的测量。更便捷的方法是用SPWM表格的索引值作为时间的指代物。 duty=k∗12(cos⁡(2πfindexsize+ϕ)+1)duty=k*\\frac{1}{2}(\\cos(2\\pi f\\frac{index}{size}+\\phi)+1) duty=k∗21​(cos(2πfsizeindex​+ϕ)+1) 其中sizesizesize是一个周期SPWM占空比表格的大小。indexindexindex是表格索引。例如，index=0index=0index=0时，计算出来的占空比就是第1个周期的占空比。这里着重分析一下sizesizesize。SPWM表格内存储一个周期的所有占空比，那么，sizesizesize就是一个正弦周期时间内，PWM的周期数，数值上等于载波比（PWM频率与正弦频率的比值）。例如PWM频率为50kHz，输出50Hz工频交流电，则sizesizesize为1000。 单片机计算SPWM表格的代码如下： 1234567891011121314151617181920212223242526272829typedef struct{ uint16_t* array; // SPWM占空比表格数组指针 uint32_t size; // 表格大小（一个周期内PWM周期数） uint32_t max_value; // PWM最大计数值（对应100%占空比） float phase; // 相位偏移 uint32_t update_max_value; // 占空比更新的最大值} SPWM_HandleTypeDef;void SPWM_Init(SPWM_HandleTypeDef* hspwm, uint32_t max_value, uint32_t freq, float phase){ hspwm-&gt;size = PWM_FREQ / freq; // 计算表格大小 uint32_t size = hspwm-&gt;size; hspwm-&gt;array = (uint16_t*)malloc((PWM_FREQ / 20) * sizeof(uint16_t)); // 分配内存 hspwm-&gt;max_value = max_value; hspwm-&gt;phase = phase; for (uint32_t i = 0; i &lt; size; i++) { uint32_t min = 0.01 * max_value; // 占空比下限 uint32_t max = 0.99 * max_value; // 占空比上限 // 计算SPWM占空比，正弦调制 uint32_t temp = max_value * (0.5f - 0.5f * arm_cos_f32(2.0f * PI * i / size + phase * 2 * PI)); if (temp &gt; max) temp = max; // 限制最大值 if (temp &lt; min) temp = min; // 限制最小值 hspwm-&gt;array[i] = temp; // 存入表格 }} 这串代码的缺点是使用了malloc函数动态分配内存。STM32的malloc会把这段内存分配到堆（heap）当中去，导致在STM32CubeMX生成代码时，必须手动增大堆大小。我最终增大到了0x8000，也就是32kB的堆大小，非常占用内存。 计算好SPWM表格后，借助STM32的定时器，可以直接产生PWM波形。为了能够实时更新占空比，传统做法是在定时器更新中断里面，手动更改CCR的值。这种方法需要中断主函数运行，占用CPU资源。考虑到SPWM表格并不会频繁变化，使用DMA持续搬运数据到定时器是个更好的办法。DMA设定如图。 需要特别注意的是，一定要记得修改DMA方向。默认方向是P2M，我们需要M2P。此外要把模式改为Circular。 为了实现SPWM波形的实时更新，我额外添加了一个更新函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455extern SPWM_HandleTypeDef hspwm_u, hspwm_v, hspwm_w;void SPWM_UpdateStart(uint32_t update_max_value, uint32_t updateFreq){ if(updateFlag == 1) return; hspwm_u.update_max_value = update_max_value; hspwm_u.size = PWM_FREQ / updateFreq; hspwm_v.update_max_value = update_max_value; hspwm_v.size = PWM_FREQ / updateFreq; hspwm_w.update_max_value = update_max_value; hspwm_w.size = PWM_FREQ / updateFreq; updateFlag = 1;}void SPWM_Update(){ if(updateFlag == 0) return; // 更新三个相的SPWM波形 SPWM_HandleTypeDef* handles[3] = {&amp;hspwm_u, &amp;hspwm_v, &amp;hspwm_w}; float phases[3] = {hspwm_u.phase, hspwm_v.phase, hspwm_w.phase}; static uint32_t lastFreq = 50; for (int h = 0; h &lt; 3; h++) { SPWM_HandleTypeDef* hspwm = handles[h]; uint32_t size = hspwm-&gt;size; uint32_t max_value = hspwm-&gt;update_max_value; float phase = phases[h]; if (hspwm-&gt;array == NULL) continue; for (uint32_t i = 0; i &lt; size; i++) { uint32_t min = 0.01 * max_value; uint32_t max = 0.99 * max_value; uint32_t temp = max_value * (0.5f - 0.5f * arm_cos_f32(2.0f * PI * i / size + phase * 2 * PI)); if(temp &gt; max) temp = max; if(temp &lt; min) temp = min; hspwm-&gt;array[i] = temp; } } if(lastFreq != freq) { HAL_TIM_PWM_Stop_DMA(&amp;htim1, TIM_CHANNEL_1); HAL_TIM_PWM_Stop_DMA(&amp;htim1, TIM_CHANNEL_2); HAL_TIM_PWM_Stop_DMA(&amp;htim1, TIM_CHANNEL_3); HAL_Delay(1); HAL_TIM_PWM_Start_DMA(&amp;htim1, TIM_CHANNEL_1, (uint32_t*)hspwm_u.array, hspwm_u.size); HAL_TIM_PWM_Start_DMA(&amp;htim1, TIM_CHANNEL_2, (uint32_t*)hspwm_v.array, hspwm_v.size); HAL_TIM_PWM_Start_DMA(&amp;htim1, TIM_CHANNEL_3, (uint32_t*)hspwm_w.array, hspwm_w.size); } lastFreq = freq; updateFlag = 0;} 这一段代码主要是重新计算SPWM表格，和维护SPWM句柄结构体。其中需要注意的是。在主函数中循环调用SPWM_Update()，在需要的时候，调用SPWM_UpdateStart()，就可以高效率修改SPWM表格，并重新输出。SPWM的更新，会导致表格长度发生变化，因为输出的正弦波频率有可能改变，即题目要求的变频功能，因此需要修改DMA长度，重新启动TIM输出。需要注意的是，重新启动TIM输出时，如果不调用HAL_TIM_PWM_Stop_DMA()函数，直接调用HAL_TIM_PWM_Start_DMA()函数来更新DMA大小，是不可行的。因为如果DMA处在Busy状态，调用Start函数不会有任何效果。 可控变频 只要前面SPWM写得好，可控变频其实并不难。变频只需要改变前面占空比公式中的fff，重新计算一遍即可，唯一需要考虑的问题是数组长度。如前所述，SPWM表格长度等于载波频率与正弦波频率之比，因此，malloc()能够分配的数组长度，需要满足频率最小时的长度，即fPWM20Hz\\frac{f_{PWM}}{20Hz}20HzfPWM​​ 交流电压、电流采样 首先，电压电流采样的数据来源于我们设计的电压、电流互感器采样模块。这个模块会输出一个以1/2VCC为中心上下波动的电压波形，表征被测电压/电流的大小。单片机通过ADC采样该电压，换算即可得到实际输出电压/电流。难点在于： 如何消除直流分量 如何校准采样过程的误差 第一个问题看似简单，采样数据减去2047不就可以了？当然不。12位ADC采样的电压精度可以达到1mV以下，如果单纯的减去2047，表面上相当于减去了1/2VCC，实际上，由于单片机的VCC与采样模块的VCC存在些许偏差，同样是3V，单片机可能是2.95，采样模块可能是3.02，单片机减去2047并没有把采样模块输出电压的直流偏置完全减去。此外，采样模块的1/2VCC，是由电源电压分压得到。分压电阻的大小也可能有些许误差，致使直流偏置量并不是严格的1/2VCC。综合来看，各个地方电压的误差，累计起来，在ADC采样数据身上，会产生很大的误差，单纯的减去2047是无法消除直流分量的。由于我们后面还要计算RMS有效值，任何直流分量都会很大的影响RMS计算结果。因此，必须用更加准确的方法去除直流分量。 借助arm_dsp库中的arm_biquad_cascade_df2T_f32()函数，可以快速计算二阶差分方程组成的IIR高通/低通滤波器。这里我们使用一个一阶IIR高通滤波器过滤掉直流分量。其差分方程如下： y[n]=x[n]−x[n−1]+α⋅y[n−1]y[n]=x[n]-x[n-1]+\\alpha\\cdot y[n-1] y[n]=x[n]−x[n−1]+α⋅y[n−1] 该差分方程是一个一阶高通滤波器。截止频率计算公式如下： fc≈(1−α)⋅fs2πfcfc\\approx\\frac{\\left(1-\\alpha\\right)\\cdot f_s}{2\\pi}fc fc≈2π(1−α)⋅fs​​fc 代入α=0.995\\alpha=0.995α=0.995，若fs=1000 Hzfs=1000\\ Hzfs=1000 Hz，求得fc≈0.796Hzfc≈0.796 Hzfc≈0.796Hz。 其幅频响应和相频响应如图。可以看出，其对低频信号的影响较大，对20Hz以上的信号基本没有影响。能够满足题目20-100Hz的变频范围需求。 ADC采样的数据，通过下面这个函数计算成有效值： 12345678910111213float RMS(uint16_t* buffer, uint32_t size){ float sum = 0; float volt; for (uint32_t i = 0; i &lt; size; i++) { volt = buffer[i] * 2.985f / 4095 / 0.0214238f; arm_biquad_cascade_df2T_f32(&amp;dcBlocker, &amp;volt, &amp;volt, 1); sum += volt * volt; } sum = sqrtf(sum / size); return sum;} 第二个问题，如何校准采样数据呢？ 在实际系统中，理论设定值（Target）和实际测量值（Real）之间往往存在系统误差，例如硬件精度、温漂、非线性等。 为了获得准确的实际输出，我们需要根据测得的校准数据，对设定值进行补偿。实际应用中，我们很容易测量出设定值与实际值的数据点，例如： Target（设定） Real（实际） 1.00 2.84 2.00 4.93 3.00 6.33 4.00 7.31 5.00 8.01 6.00 8.50 7.00 8.88 8.00 9.16 9.00 9.38 如果我们想得到实际输出=3.0V，直接设定Target=3.0V会导致输出电压为6.33V。为了得到真正的3.0V，我们需要将设定值调整到大约1.1V。这就是这套校准理论的核心。 左侧的图是传统思维画出的输出曲线，他代表了不同的设定值下，输出值的变化。但这不是我们想要的。我们需要的实际上是这个函数的反函数，也就是右侧的图。可以看到，如果我输入x=6，y=2.76，也就是说，我想要实际输出电压为6时，设定电压应当为2.76，因此，我只要构建出右侧的函数曲线，即可实现目标值与实际值的校准。 这里我专门写了一个校准用的库，可以用在各个项目里面，将理论值与实际值建立起一个函数关系，然后用实际值逆推出理论值，实现校准功能。 这块主要是AI写的代码，我只是提供了思路。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void Calibration_Init(Calibration_HandleTypeDef* cali, const float* target, const float* real, uint32_t length){ if (length &lt; 2 || target == NULL || real == NULL) { // Handle invalid input return; } // Initialize the calibration structure cali-&gt;target = target; cali-&gt;real = real; cali-&gt;length = length; // Allocate memory for k and b arrays cali-&gt;k = (float*)malloc(sizeof(float) * (length - 1)); cali-&gt;b = (float*)malloc(sizeof(float) * (length - 1)); if (cali-&gt;k == NULL || cali-&gt;b == NULL) { // Handle memory allocation failure return; } // Calculate segments for (uint32_t i = 0; i &lt; cali-&gt;length - 1; i++) { float x0 = cali-&gt;real[i]; float x1 = cali-&gt;real[i+1]; float y0 = cali-&gt;target[i]; float y1 = cali-&gt;target[i+1]; cali-&gt;k[i] = (y1 - y0) / (x1 - x0); cali-&gt;b[i] = y0 - cali-&gt;k[i] * x0; }}float Calibration_Apply(Calibration_HandleTypeDef* cali, float real_value){ // Overflow and underflow checks if (real_value &lt;= cali-&gt;real[0]) return cali-&gt;k[0] * real_value + cali-&gt;b[0]; if (real_value &gt;= cali-&gt;real[cali-&gt;length - 1]) return cali-&gt;k[cali-&gt;length - 2] * real_value + cali-&gt;b[cali-&gt;length - 2]; // Find the segment for the given real_value for (uint32_t i = 0; i &lt; cali-&gt;length - 1; ++i) { if (real_value &gt;= cali-&gt;real[i] &amp;&amp; real_value &lt;= cali-&gt;real[i+1]) { return cali-&gt;k[i] * real_value + cali-&gt;b[i]; } } // In case no segment found, return an error value or handle it appropriately return -1;} PID闭环调节 PID属于老生常谈的问题了。需要注意的是，为了更加稳定的调节输出电压，我使用了增量式PID控制器，实时调控SPWM的调制比，从而控制输出电压。PID我也写成了一个库，各个项目都能用，直接看代码即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef struct { float Kp; // Proportional gain float Ki; // Integral gain float Kd; // Derivative gain float target; // Desired value float integral; // Integral term float integral_limit; // Limit for integral term to prevent windup float previous_error; // Previous error for derivative calculation float prev_prev_error;} PID_HandleTypeDef;void PID_Init(PID_HandleTypeDef *pid, float kp, float ki, float kd, float integral_limit){ pid-&gt;Kp = kp; pid-&gt;Ki = ki; pid-&gt;Kd = kd; pid-&gt;previous_error = 0.0f; pid-&gt;integral = 0.0f; pid-&gt;integral_limit = integral_limit;}void PID_SetTarget(PID_HandleTypeDef *pid, float target){ pid-&gt;target = target;}void PID_Reset(PID_HandleTypeDef *pid){ pid-&gt;integral = 0.0f; pid-&gt;previous_error = 0.0f;}void PID_Compute(PID_HandleTypeDef *pid, float current_value, float *output){ float error = pid-&gt;target - current_value; pid-&gt;integral += error; // Limit integral to prevent windup if (pid-&gt;integral &gt; pid-&gt;integral_limit) { pid-&gt;integral = pid-&gt;integral_limit; } else if (pid-&gt;integral &lt; -pid-&gt;integral_limit) { pid-&gt;integral = -pid-&gt;integral_limit; } float derivative = error - pid-&gt;previous_error; *output = pid-&gt;Kp * error + pid-&gt;Ki * pid-&gt;integral + pid-&gt;Kd * derivative; pid-&gt;previous_error = error;}void PID_ComputeIncremental(PID_HandleTypeDef *pid, float current_value, float *output){ float error = pid-&gt;target - current_value; float delta_output = pid-&gt;Kp * (error - pid-&gt;previous_error) + pid-&gt;Ki * error + pid-&gt;Kd * (error - 2 * pid-&gt;previous_error + pid-&gt;prev_prev_error); *output += delta_output; pid-&gt;prev_prev_error = pid-&gt;previous_error; pid-&gt;previous_error = error;} 至此，三相逆变器的设计就介绍完了。 电压电流采样模块设计 该模块来源于立创开源广场，开源连接，做了部分修改。 1. 互感器电路设计 电压电流采样都是用互感器隔离采样的，但是电压和电流不能选择同样的互感器。电压互感器是并联在电路中的，流过的电流应当很小（内阻很大），而电流互感器是串联在电路中的，有可能流过很大的电流。所有的互感器都是将电流按比例感应到次级，因此电压互感器，流过小电流，应当有很小的电流互感比。电流互感器，流过大电流，应当有很大的互感比，使得次级电流很小。同时，次级必须有I-V转换电路（一个电阻或者一个跨阻放大器）将电流信号转变为电压信号。 2. 放大电路设计 放大电路主要负责：将电流信号转变为电压信号、抬升至1/2VCC、放大一定的倍数。这块电路很简单，参考开源链接即可。 馈流电路设计 1. 理论分析 按照题目要求，需要将三相交流电变流送回直流输入端，实现能量回馈的功能。那么，如果馈流电路接入直流输入端，就会形成两路直流电源并联的情况，此时，必须有一方以电流源的形式输出，否则会因为微小的电压差异灌入大电流。因此，馈流电路的基本思路就确定了，是一个恒流输出的直流电源，输入三相交流电，输出恒流直流电。 2. 拓扑选择 首先，三相交流电转直流电，有很多种办法，最简单的就是二极管整流电路。 这样整流得到的电压是固定的，如果交流线电压为32V的话，整流输出电压大约为46V。显然，经过逆变-整流的操作，直流电压相比于输入的时候明显下降了。因此想要将能量输送回去，需要升压。 升压拓扑有很多种，常用的无非就是Boost电路和反激电路。二者最大区别在于隔离/非隔离。我们逆变出的相电压，实际上是以电源地为参考的，而线电压是相电压的差，事实上也是以电源地为参考的，并不是浮地的，因此整流出来的电压，也是以电源地为参考的，并不是浮地或者有高共模电压的。综合来看，这个升压不需要隔离拓扑就可以，因此我们选择Boost拓扑作为馈流电路的主拓扑 3. 方案设计 整流电路刚才已经介绍过了，使用最基本的二极管整流就可以。不过，二极管整流会导致效率下降，馈流之后的直流电源输出电流偏高，馈流效率较低。我们做方案的时候并没有太考虑效率的问题，于是就使用了最简单的方案。 Boost电路我们设计了两种方案，一种是数控双向DC-DC、PID恒流，另一种是采用L6561芯片搭建的恒流控制电路。 L6561虽然是一个PFC控制芯片，但是只要将MULT引脚接入直流电平，而不是接入交流参考波形，就可以当作一个普通的恒流控制芯片使用。因为实验室这款芯片有很多，而且工作起来比较稳定，就选择了这个芯片做控制。 数控方案我们使用预先设计好的双向DC-DC模块制作的，模块集成了双向的电流采样、电压采样、半桥驱动等。回馈效果也很好，但是一旦接入，单片机计算量就太大了，因此放弃了数控方案。下面是双向DC-DC的原理图 连接单元 题目当中的连接单元，只在发挥部分有提到，是三相逆变和三相整流之间的连接。在这个题目中，按照我的理解，这个连接单元就是三根导线，将逆变出来的三相电接入整流电路，因此并不存在什么连接单元的说法。 我将连接单元的概念扩展到了基础部分，设计成了一个基础部分与扩展部分的切换单元，使用一个三路双控开关，公共端接入逆变器输出，一端接入馈流单元，另一端接入三相电阻负载，这样如果开关打到上端，就将逆变器接入馈流单元，打到下端就接入三相负载。 作品接线 由于我们没有设计自己的开发板，使用的成品开发板，开发板的IO口都是由杜邦线引出的。众所周知，杜邦线在电赛当中百害而无利，需要尽可能避免。为了能将开发板的IO口牢牢的引出，我们在一块洞洞板上焊接杜邦母座，整个开发板插入，在洞洞板边缘焊接好需要的接插件（主要包括XH2.54接口和KF2EDG15K系列5.08mm的接插件），形成一个“转接板”，接插件与杜邦母座连接好线，接插件就可以随意连接到其他模块上。模拟信号全部用SMA连接器，在洞洞板上将SMA焊接好后，引线连接到IO口母座的位置，就可以连接进单片机。这样，既不破坏单片机开发板，又能够随时根据需要调整IO口引出，适应不同的赛题和作品，不需要更换单片机开发板，只需要更换一个转接板即可。","link":"/blog/2025/08/08/25%E7%94%B5%E8%B5%9BA%E9%A2%98%E6%BB%A1%E5%88%86%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90/"},{"title":"CarSim仿真基础","text":"最近学习CarSim+Simulink联合仿真，开发FSEC大学生方程式赛车的TCS算法，记录一下学习过程 CarSim简介 CarSim是一款强大的汽车仿真、自动驾驶仿真软件，具有真实的物理引擎，能够模拟各类路面、风等环境与各类发动机、变速箱、差速器乃至电动机、电池构成的车辆。 CarSim数据结构 1. Database Database是Carsim中最大的一个数据结构。一台电脑中，可以存在多个Database。每一个Database的数据不互通，因此可以实现备份、分盘等作用。一个Database对应一个电脑的物理地址，所以其本质就是一个文件夹。 2. Dataset Dataset顾名思义就是数据集，也就是一系列数据的集合。他在不同的地方会有不同的含义。这里强烈建议观察一下左下角的树状图 例如，如果选择Run Control的Dataset，这一个数据集包含Models, Animator, Vehicle, Procedures, Plot等五个部分的数据集。选择好了Run Control的数据集后，如果想要修改一部分仿真参数，可以分别修改每一个模块的数据集。例如，如果把Vehicle的数据集修改掉，那么只修改了这个仿真的车辆，其他部分不变。当然，Vehicle数据集，也包含很多小数据集，修改一个Vehicle数据集是同步修改了包含的所有小数据集。数据集是由一堆数据集嵌套而成的，整个软件中，最大的数据集，就是Run Control数据集，它包含了仿真的所有参数和数据。它可以对应到其他软件常见的“工程”的概念。 Carsim常用参数 Math Model数据集 这个数据集包含了车辆的所有基本信息，例如长度、宽度、轴距、重心、重量等。 Procedure数据集 这个数据集包含了仿真的流程。例如：地图、路面、路线、加速、减速、起始位置、视角等关键数据。 Model:Simulink数据集 想要将CarSim与Simulink联合仿真，必须让Carsim输出我们想要的数据到Simulink，同时让Carsim从Simulink中输入我们想要的数据，实现Simulink对Carsim的监控或者控制。这个数据集就负责控制Carsim的输入/输出数据。数据集内有以下画面。 Import Channels就是输入数据，Export Channels就是输出数据。进入其中一个数据集，可以看到以下画面： 在这里就可以选择各种你想要控制的数据，双击需要的数据，将会把它添加到最右侧Variables Activated for Import栏。这个栏的顺序，就是Simulink中，输入向量的顺序。","link":"/blog/2025/09/05/CarSim%E4%BB%BF%E7%9C%9F%E5%9F%BA%E7%A1%80/"},{"title":"MAX30100心率检测算法","text":"前言 最近的项目需要实现心率检测的功能，经过简单的搜索后决定使用基于MAX30100的心率监测模块实现这个功能项目使用STM32作为主控，通过IIC总线协议与模块进行通信，本篇博文主要记述心率监测开发和调试过程。 基本原理 检测原理 MAX30100本质上是LED驱动器+光敏传感器+高精度ADC。首先，手指毛细血管中的红细胞，在含氧量不同的情况下，吸收特定波长的光的能力是不同的，因此，反射出去的光强也会随着含氧量有所变化。一次心跳会把含氧量高的动脉血泵到手指末端，使得红细胞含氧量增加，进而导致反射光的能力发生变化。MAX30100通过光敏传感器和ADC，实时读取反射光的强度，配合软件算法，可以计算出心率。同时，反射光的强度间接反映含氧量，可以通过经验算法，推算出指尖含氧量，即SpO2SpO_2SpO2​。 算法原理 MAX30100并不内置软件算法，他会原封不动的把ADC数据发送出去，由MCU进行心率计算。这里引用一个网上的图片。 原始博客链接找不到了，在这里说声抱歉 可以发现，原始数据上，根本看不出来数据随着心跳的变化。但是经过直流滤波+卷积滤波之后，能明显的看出来数据上下起伏，这个起伏的频率就是心跳的速度。 为了求出这个起伏的频率，我们可以应用两种方法。首先是比较简单的一种，直接把原始数据扔进FFT里面，他应该能自动求出数据变化的频率，我们只需要找到除了低频分量以外的最高峰即可。第二种方法，是对原始数据进行直流滤波+卷积之后，应用动态阈值算法，实现对原始数据交错次数的计数，从而得到变化频率。 我主要采用第一种方法。 硬件设计 没啥好说的，IIC，上拉电阻，配齐了就能用 软件设计 初始化 初始化部分主要是设置MAX30100的工作模式。我主要调整的是： LED驱动电流24mA LED脉宽1600us，即ADC采样位数16bit 采样速率200samples/s 数据采集 MAX30100采用FIFO存储数据，大小为16，如果数据没有被及时读取，多余的数据会被丢弃。因此，MAX30100最多存储16200s\\frac{16}{200}s20016​s的数据。只要IIC读取走了一个数据，下一次读取的就一定是最新的数据。 虽然MAX30100设置了200sps的采样率，但是实际上，我每隔20ms才读取一次，也就是说1s读取50个点，采样率为50Hz。一般来说，采样率不是越高越好吗？为什么要故意降低采样率呢？后面FFT部分会详细解释。 FFT 由于FFT的特点，FFT的频率分辨率可以表示为： fres=fsampleNFFT≈0.0244f_{res}=\\frac{f_{sample}}{N_{FFT}}\\approx0.0244 fres​=NFFT​fsample​​≈0.0244 其中，fsamplef_{sample}fsample​即数据采样的频率，NFFTN_{FFT}NFFT​即FFT点数。 由于FFT计算出来的是频率，即每秒周期数，而心率一般都是用每分钟心跳数来表示的，他与每秒心跳数差 60倍。考虑到这个因素，心跳的分辨率应该是频率分辨率的60倍。 HeartBeatres=60fres≈1.465HeartBeat_{res}=60f_{res}\\approx1.465 HeartBeatres​=60fres​≈1.465 也就是说，心率的分辨率是1.5左右。那么，我检测出来的心率，不可能出现两个步进的中间值，比如1.5的两个整数倍数分别是60，61.5，我不可能检测出来61次/min，也不可能检测出62次/min。因此，如果这个心率分辨率比较大，得到的心率数据效果很不好，误差会很大。 我们仔细分析心率分辨率的计算，可以发现，如果fsamplef_{sample}fsample​比较大，那么心率分辨率就会大，分辨能力差。如果FFT点数比较大，那么整体的分辨率变小，分辨能力提高。以上的数据都是以50sps的采样率计算的，且FFT点数为2048，即使采样率慢成这样、FFT点数这么高，得到的心率分辨率仍然比1大，效果仍然一般。这就是为什么我们要扔掉大量的采样数据，降低采样率，为了换取更高的心率分辨率。 降低采样率虽然能提高心率分辨率，但是会显著降低采样速度，导致心率刷新率慢。比如我现在50sps的情况下，如果采满2048个采样点再做FFT，一次采样需要40多秒。这个速度实在是太慢了。我为了提高采样速度，选择降低采样点数，具体方法是，采集满一定数量的点数就开始FFT，其余的数据点用0填充，这样不需要等待2048个采样点全部采满。坏处是，由于FFT的数据只有一部分有效，会导致FFT的结果不准确。 数据 最开始计算完FFT的时候，通过串口打印2048个数据，绘图，得到了采样数据的频谱。 可以看出，这个频谱图出现了规律性的波动，专业上应该有一个名词对应，但是我不知道。这种波动对峰值检测有一定的影响。我对原始数据添加汉宁窗之后，频谱的波动消失了 这样的波形就比较好看了，峰值的位置也是对的，只不过由于FFT精度有限，测量的心率结果仍然很差，只能说这个传感器使用起来还是挺困难的。 总结 MAX30100这款心率检测传感器的使用具有一定的困难，得到的检测结果也有较大的误差，需要进一步优化算法，提高对离散数据采集和处理的能力。","link":"/blog/2025/05/07/MAX30100%E5%BF%83%E7%8E%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"},{"title":"STM32 USB声卡设计","text":"前言 根据我日常使用的需求，需要设计一款Type-C连接的外置USB声卡，用于播放声音。本质上就是把USB Audio协议的数字音频信号转换成模拟信号，并从3.5mm耳机孔输出。本文将详细介绍这款USB声卡的设计、调试过程，为之后的开发积累经验。 构思 设计指标 这款声卡的音质尽可能好，尽量达到HiFi的标准。采样率不需要很大，48K即可，较高的采样率会导致Windows端超采样音源，得不偿失。位深度也不需要太大，16bit即可。最好能够兼容多重采样率和位深度。此外，这款声卡不允许有任何可闻底噪。 方案选择 DAC芯片 市面上的DAC芯片很多，例如近期比较火热的CS43198，经久不衰的旗舰AK4499、ES9018，性价比较高的ES9038Q2M、PCM27xx之类的。 我需要保证以下几点： 价格不高，20元以内，尽可能便宜一些 易于购买，至少在tb有多家可靠店铺售卖 支持的采样率和位深度满足需求 具有控制接口，能够在硬件上控制音量 综合各方面因素，我选择CS4398这款音频专用DAC芯片。首先其价格不贵，12元一片，支持24bit 192k，远远超过我的需求。这款芯片是十年前Cirrus Logic的旗舰芯片，有很多顶尖台式解码器使用这个芯片，音质应该没有问题。 数字界面 几乎所有的音频DAC都需要I2S接口输入数据，I2S接口既包含音频数据，也包含该数据对应的采样率等信息，甚至可以为DAC芯片提供运行时钟。但是电脑是没有I2S接口的，这款声卡需要把电脑的USB音频信号转成I2S信号输出给DAC。这个过程是由数字界面完成的。 高端的数字界面一般都是使用Amanero或者XMOS的专用芯片，但这些芯片不仅贵的离谱而且非常不好购买。此外还有CT7601、CM108之类的专用芯片，价格还算可以接受，但是仍然不好购买。 我认为，数字的信号，传输过程是不会出现失真的，任何芯片都不可能把本来是0xC3的数据传输成0xC4，所以我想在数字界面上节省开支。我最终选择使用STM32作为数字界面芯片，其具有USB-OTG接口和I2S接口，只需要编写程序把数据搬移到I2S即可。 耳放 耳机放大器其实就是运算放大器，是3.5mm耳机接口前的最后一级，负责把DAC输出的模拟信号进行变换（I/V转换）、放大（或缩小）、滤波（低通滤波器），以便输出给耳机。由于我选择的DAC内部自带IV转换，输出的直接就是电压信号，所以运放只需要进行放大和滤波就足够。我选择的是TI家的OPA1642音频专用运放，主要看中他的输出电流不小，噪声很小的特点。 电源 HiFi设备的电源需要非常认真的设计，因为电源的抖动会直接耦合到模拟信号上，造成失真和底噪。由于不想引入额外噪声，我没有使用常用的隔直电容耦合音频信号，而是给整个系统引入负电源，使其具备双极性输出的能力。 这时候我发现了一款非常合适的芯片——LM27762。它具有正负双LDO，以及负电源电荷泵。只需五个外部电容，即可实现+5V转正负双电源，而且都是LDO输出的电源，可以直接作为模拟电路的供电。这款芯片看起来非常优秀，但是就是因为这个芯片的使用，给后面的调试带来了很大的困难。 MCU和DAC数字电源使用一个ME6211产生3.3V，没有什么可说的。 硬件设计 时钟 CS4398这款DAC需要I2S提供MCLK信号作为其工作的主时钟。但是STM32的I2S接口如果输出MCLK的话，时钟精度就会下降。例如，I2S设置48kHz的采样率，实际上，由于时钟误差，他的采样率是47.991kHz。这个采样率直接决定了I2S输出数据的速度。所以，这个采样率误差会导致I2S发送数据慢了9Hz。假设USB以48.000kHz输出数据，那么I2S就发不完USB传来的数据，最终会导致缓冲区溢出。所以，最好的办法是给STM32的I2S提供一个专用时钟，比如使用24.576MHz的晶振。在我的设计中，没有采用这个方案，仍然是8MHz晶振通过PLL产生I2S MCLK。通过算法解决缓冲区溢出的问题。 电源 电源电路的设计使用了0欧电阻隔离数字地和模拟地，用磁珠隔离VBUS和+5V，减少+5V的噪声。由于DAC需要+5V作为模拟供电，最简单的办法就是从VBUS获取，但是VBUS耦合了电脑的噪声，因此需要对其进行滤波。也可以采用升压+LDO的方式，但是显然会增加系统复杂度，这次就不考虑了。 原理图 软件开发 软件主要使用STM32CubeMX生成。其设置如下。 配置的时候需要把Middleware里面的USB DEVICE CLASS启用，选择USB Audio Class。PID和VID可以根据需要修改，设备名也可以自定义。这里我给设备起名叫做STM32 Audio Card。 其次需要配置I2S的DMA，启用后，Mode保持默认，启用FIFO，Threshold设为Full，设置RAM的Burst Size为8 Increment，Peripheral的Burst Size设为No Increment。 配置完成之后，首先要实现USB数据的转发。STM32的USB Class库封装了AUDIO_AudioCmd_FS函数，在接收USB数据后会自动调用这个函数，通过传入不同的Cmd，执行不同的功能，修改这个函数，在其中增加对HAL_I2S_Transmit_DMA()的调用即可。 12345678910111213static int8_t AUDIO_AudioCmd_FS(uint8_t* pbuf, uint32_t size, uint8_t cmd){ switch(cmd) { case AUDIO_CMD_START: HAL_I2S_Transmit_DMA(&amp;hi2s1, pbuf, size); break; case AUDIO_CMD_PLAY: HAL_I2S_Transmit_DMA(&amp;hi2s1, pbuf, size); break; } return USBD_OK;} 然后，由于USB Audio的Sync函数需要在I2S传输完成后调用，因此增加I2S的半满和全满中断。 1234567891011121314void HAL_I2S_TxHalfTransferCpltCallback(I2S_HandleTypeDef *hi2s){ if(hi2s == &amp;hi2s1) { HalfTransfer_Callback_FS(); }}void HAL_I2S_TxTransferCpltCallback(I2S_HandleTypeDef *hi2s){ if(hi2s == &amp;hi2s1) { TransferComplete_Callback_FS(); }} 此外，需要通过I2C接口对CS4398进行操作。根据数据手册，编写CS4398的驱动代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void CS4398_Write(uint8_t reg, uint8_t data){ extern I2C_HandleTypeDef hi2c1; uint8_t txData[2] = {reg, data}; HAL_I2C_Master_Transmit(&amp;hi2c1, CS4398_ADDR, txData, 2, 100); }/* * @brief Initialize the CS4398 * @param None * @retval None * @note By calling this function, the CS4398 is enabled and the volume is set to minimum */void CS4398_Init(void){ CS4398_Write(0x09, 0xC0); // Enable Control Interface HAL_Delay(1); CS4398_Write(0x03, 0x89); // Equal A and B volume HAL_Delay(1); CS4398_Write(0x05, 255); // Set volume to minimum HAL_Delay(1); CS4398_Write(0x07, 0xB0); // Set soft ramp mode}/* * @brief Set the volume of the CS4398 * @param volume: 0x00 to 0xFF * @retval None * @note 0x00 is the maximum volume, 0xFF is the minimum volume * The volume is set to both channels */void CS4398_SetVolume(uint8_t volume){ CS4398_Write(0x05, volume);}/* * @brief Mute the CS4398 * @param None * @retval None * @note CS4398 is muted in hardware */void CS4398_Mute(void){ CS4398_Write(0x04, 0x18);}/* * @brief Unmute the CS4398 * @param None * @retval None * @note CS4398 is unmuted in hardware */void CS4398_Unmute(void){ CS4398_Write(0x04, 0x00);} 调试 焊接效果 硬件调试 上电测试 万用表测试+5V和GND没有短路之后，使用可调电源给板子提供5V工作电压。观察到电流0.02A，3.3V、+4.2V、-4.2V均正常输出。 USB供电测试 使用USB供电之后，问题就出现了。刚才正常的+4.2V、-4.2V现在不正常了，输出电压呈现非常大幅度的变化，大体呈现三角波的形状。 测试进行到这里，遇到了很大的问题。经过排查，发现问题出在USB的VBUS供电上。使用可调电源提供供电的时候，+5V波动较小，使用电脑USB供电时，由于USB的瞬时电流提供能力不足，出现掉压的现象，掉压幅度达到了200mV。 进一步排查发现，USB VBUS的掉压是周期性的，频率大约为30kHz。这个现象不算很奇怪，很有可能是开关电源导致的瞬时电流拉低了VBUS电压。整个电路中只有电荷泵是开关电源，问题只可能出在这里。但是这样就说不通了，电荷泵的开关频率是2.2MHz，怎么可能出现30kHz左右的波动呢？ 改回可调电源供电，用示波器查看LM27762的电荷泵电容，可以看到一个特殊的现象，LM27762先工作在连续开关模式，这时电流是连续的，然后工作在PFM模式，开关波形始终为高电平，此时电流为0，一段时间后，从PFM模式转变为连续开关模式，这个过程会导致电流从0突变为一个大于0的值，过一段时间后再次进入PFM模式。这个模式变换的频率，与VBUS掉压的频率完全相符。观察他们的对应关系发现，正是PFM转换成连续开关模式的一瞬间，产生了VBUS的掉压。问题的源头找到了。 下一个困难就是，怎么解决这个问题呢？PFM是开关电源在轻载状况下提高效率、降低损耗用的，只要提高输出电流就肯定能解决这个问题。但是这个电荷泵的输出电流有250mA，在我的电路中，他只给运放提供负电源，工作电流1mA可能都没有。如果硬要把电流提高，那么损耗也太大了点，99%的电流都会损耗掉。 目前没有更好的办法，只能先并联电阻提高输出电流。将一个100欧姆的电阻并联在-4.2V的输出上，用来提高输出电流。观察开关波形发现，PFM的切换频率提高了，也就是说，提高电流会加快PFM的变换，那么再提高点是不是就一直出在PWM模式了。 再并联一个100欧姆的电阻并联在-4.2V的输出上，形成50欧姆左右的负载，电流大约10mA，PFM变换速率更快了，但是还是无法满足要求。 上网查找资料，发现在TI的E2E论坛上，有人提出过这个问题。参考https://e2e.ti.com/support/power-management-group/power-management/f/power-management-forum/1054414/lm27762-pfm-and-constant-switching-frequency-for-light-load上的方案。首先将Cp减少一半，没什么效果，仍然会工作在PFM和PWM快速变换的状态。其次，在Cp上并联100欧姆电阻，直接在电荷泵上消耗电流，并联完成之后，USB供电也能够正常工作了。 这个问题可能是芯片设计缺陷，也很有可能是我的PCB走线有点太随意了，LM27762的供电过了好几个过孔，进一步恶化了瞬态电流相应。后续可以重新设计PCB，有可能能解决这个问题。此外，LM27762的VIN电容最好能够加大一些，来抵消电感导致的电压突变效应。 软件调试 软件上没有遇到很大的问题。软件烧录完成后，插上耳机，就能够正常听到电脑的声音了。 STM32官方的USB Audio库在软件上解决了电脑和声卡音频频率不匹配的问题，具体解决的方法是如果检测到I2S发送的较慢，则跳过4个数据点，从第五个开始发送，来弥补时钟频率慢导致的发送速度慢。这种方法显然会损失音频的保真程度，而且会导致音频不连续的问题。但是实际测试下来，正常播放音乐、视频、玩游戏，声音并没有可闻瑕疵。这一点是USB Audio的硬伤，到目前没有什么很好的解决方案。 存在问题 CS4398的输出幅值太高了，耳放也没有对其进行有效的限幅，导致就算CS4398的音量设置成最小（－125dB），插上耳机声音仍然很大，导致软件上必须把CS4398的音量设置成最小。 如果进入游戏，然后强制退出游戏，游戏的声音会在耳机上不断播放，就像卡带了一样。这个原因主要是USB突然不再发送音频了之后，STM32的DMA并不会停止发送，会一直发送缓冲区中的数据。这点最终没有再花时间解决，因为只要随便播放一个音频，就能够覆盖掉缓冲区的内容，就不会再重复播放了。不算是什么大问题 重新插上声卡后，电脑上需要较长的时间识别STM32声卡，这段时间无法使用。原因应该是没有在USB D+上添加上拉电阻，导致电脑只能通过定时的硬件扫描找到声卡，无法实现插入瞬间的识别。这个问题目前没有解决的计划，由于我的声卡永远插在电脑上，开机的时候就识别好了，不影响使用。 播放单一频率音频时，会有规律性的电流“嗒嗒”声音。这是由于I2S频率不是精准的48kHz，导致USB发送的数据无法被I2S全部转发，算法上发现缓冲区将满，强制跳过了4个采样点，导致的声音不连续。但是正常播放音乐或者声音是没有这种情况的，不影响使用。想要解决也简单，给I2S提供专用时钟或者直接把STM32的工作晶振改成24.576MHz，这样能够产生一个没有误差的48kHz采样时钟。 总结 这次STM32的声卡制作花费了一定的时间，而且遇到了不少的问题。完成了硬件和软件的开发调试之后，我也为他制作了一个简单的外壳，安装到位之后，想要修改程序压根不可能了。后续如果想要改版，解决一些问题的话，就得重新设计PCB了。整体上，音质效果很好，听下来没有什么瑕疵，动态范围也还可以，安静情况下没有底噪，整体上达到了设计指标和要求。这个项目算得是一个比较成功的项目。","link":"/blog/2025/03/01/STM32%20USB%E5%A3%B0%E5%8D%A1%E8%AE%BE%E8%AE%A1/"},{"title":"STM32+TouchGFX+FMC驱动8080并口LCD屏幕的那些坑","text":"我也是疯了，想用8080并口的LCD屏幕。更疯狂的是，想用TouchGFX实现GUI。一路遇到了数不清的坑，最终也是实现了基本功能了。 基本思路 我使用的是一块170*320的LCD屏幕，ST7789驱动，通过30Pin FPC排线与PCB连接。 ST7789的驱动，我想用CubeMX里，X-CUBE-DISPLAY这个库直接生成。GUI部分，想用TouchGFX实现。 需要解决的问题有三： FMC的设置问题 TouchGFX与X-CUBE-DISPLAY的联合问题 TouchGFX的设置问题 第一大坑：FMC的设置问题 坑1：地址设置 FMC设置包括：Chip Select, Memory Type, LCD Register Select, Data width。以上设置内容都只能算基础。 Chip Select不同，会导致CS的IO口不同。例如Chip Select NE1对应PC7。 Memory Type区分SDRAM，PSRAM，NOR FLASH，LCD等。这里显然选择LCD。 LCD Register Select对应LCD接口的DC引脚。若LCD Register Select为0，则向寄存器写入。若LCD Register Select为1，则向内存写入。 Data width顾名思义。这里设置成8位。 其中最关键的有两个，一个是Chip Select，一个是LCD Register Select。 Bank0对应的地址范围，是从0x6000 0000到0x6FFF FFFF，NE1-NE4分别对应其中的四个子区域，即NE1的首地址位0x6000 0000。NE2的首地址是0x6400 0000。以此类推。因此Chip Select决定了LCD地址的段地址。 LCD Register Select有A0-A25可选。这个A0-A25对应到了地址的第0位到第25位。例如，如果选择A0，那么寄存器首地址就是0x6000 0000，内存首地址就是0x6000 0001，如果选择A1，则寄存器首地址就是0x6000 0000，内存首地址是寄存器首地址就是0x6000 0002。不论是地址哪一位接到LCD，对LCD来说都是可用的，但是对STM32而言，对应的地址完全不同。因此需要谨慎选择。我倾向于选择最低位。 NE1+A0的选择，得到的内存范围是0x6000 0000~0x63FF FFFF，寄存器是偶地址，内存是奇地址。实际上，因为地址线只有8位，加上A0，只有九位，因此理论上最多使用到0x6000 01FF 坑2：时序设置","link":"/blog/2025/12/28/STM32-TouchGFX-FMC%E9%A9%B1%E5%8A%A88080%E5%B9%B6%E5%8F%A3LCD%E5%B1%8F%E5%B9%95%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"},{"title":"STM32H7电赛开发板硬件设计","text":"前言 电赛国赛即将来临，我想训练训练一些电赛的真题，首先想到的就是前年实验室学长打的2023年H题——信号分离装置。因此想设计一个开发板，既能够训练这个题目，也能够作为一个ADC、DAC的板子，为电赛比赛期间使用。 思路 这个板子主要想模仿B站一位大神的H题思路，FFT+IFFT直接得到两个不同的波形，然后直接输出到DAC。由于FFT本身就含有相位信息，如果直接IFFT得到时域波形也含有相位信息，相当于在采样和恢复的过程中内置了锁相环。只要FFT和IFFT的刷新速度够快，可以实现无锁相环的相位锁定。这个思路是我根据这个大神的视频自己理解的，不一定正确，还需要把实物做出来之后验证一下。 考虑到H题的最高信号频率为100kHz，而STM32H750自带的ADC速度可以达到6Msps（8bit模式），一个周期最少可以有60个采样点，相当相当的足够，所以就没有外挂ADC。而DAC的速率，按照AN4566应用手册的描述，DAC速率可以通过外挂缓冲运放提高，理论上可以提高到数据输入的最高速率40.8Msps。虽然我觉得这个数据有夸张的成分，但是肯定也是完全足够恢复整个信号的。 综合这些考虑，我使用STM32H750VBT6作为主控，搭配OPA690电压反馈运放作为输入输出调理电路，引出尽可能多的引脚，设计了一款STM32H7的电赛开发板。 原理图设计 ADC采样调理电路 由于STM32的ADC输入范围是0－+Vref0－+V_{ref}0－+Vref​，而一般情况下输入信号都是双极性的，直流分量为0，所以需要一个调理电路，把双极性的输入信号转成0－3.3V的信号，供ADC采样。很重要的一点是运放的输出范围。由于高速运放一般不具备轨到轨特性，0－5V的电源范围实际上只能输出1－4V的信号，因此为了最大化输出摆幅，我将输出的直流偏置设置成2V，这样输出摆幅可以做到2V左右。 电路如图所示。 这个电路的反馈回路是交流耦合的，这样可以实现仅对交流信号的放大、直流信号不变。 这个电路有一个很大的缺陷，就是它对输入信号是交流耦合的，即使我把耦合电容给到22uF，最终得到的频率响应的截止频率差不多在100Hz左右，小于这个频率的信号就无法正常通过了。这块电路最好是能找一找别的解决方法，实现直流耦合条件下的输入偏置变换。 DAC输出调理电路 DAC的输出有两个作用，一方面把DAC输出的0－3.3V信号转换成双极性输出，另一方面借助运放的特性，提高DAC的采样速率，实现更高速度的DAC输出。这一块电路主要参照AN4566应用手册中的描述，然后输出的时候增加一个耦合电容，就可以把单极性输出的信号转换成双极性。考虑到高频阻抗匹配的问题，增加一个50欧姆的输出内阻。这个阻抗需要考虑到DAC内部输出的阻抗和耦合电容的阻抗，适当进行调整，比如改成22欧姆。 其他 电源 依旧是用烂了的SY8089，万能DC-DC，效果好，元件少。 外部接口 考虑到开发板的特性，最好还是能够引出大部分IO口。受限于板子尺寸，最多只有三面能够安放排针，我个人又很讨厌使用双排针，因此最终只引出了PE[15:0]、PD[15:0]、部分PC和PA口。这一块因为画的时候有点草率，IO口的配置其实不是最合理的。STM32的IO口，PA和PB的功能时最多的，应该尽可能多引出PA和PB的接口。后面的设计应当以此为经验。 PCB设计 设计完了之后，才发现DAC只引出了一路输出，所以这个板子没有打样，也没时间重画了。 PCB设计时，首先考虑到三路模拟信号的线路，把运放和SMA座子摆好。整个模拟线路和运放区域都要双面挖空铺铜，防止PCB寄生电容影响信号带宽。走线尽量宽而顺，弯折处使用圆弧连接，最大限度保证阻抗匹配。 实际上，STM32H7的ADC没有那么高的精度，也不是很有必要在信号通路上下这么大功夫。 其他的电路就没有什么好说的了，都是STM32开发板的典型设计，只不过由于线路较多，需要仔细安排走线顺序，尽量少打孔，保证信号的完整性。","link":"/blog/2025/04/24/STM32H7%E7%94%B5%E8%B5%9B%E5%BC%80%E5%8F%91%E6%9D%BF%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"},{"title":"TCS算法迭代更新","text":"本文是对之前开发的TCS算法的一次更新，提高了算法的可靠性和有效性，并补充了不同路面条件下的测试结果 缺陷和不足 此前开发的TCS算法，从思路到实现上存在诸多不足，主要包括以下几点： PID计算方式有误，下文将详细解释 存在持续积分的问题，积分未清零，多次使用TCS会累计误差 对车辆静止或车辆抓地力强等不需要TCS介入的条件没有感知，TCS始终开启，有可能出现危险 PID补偿扭矩的上下限没有动态调整。针对不同的车手输入扭矩，应当有不同的上下限 针对上述问题，在比赛结束季后阶段，对TCS算法进行迭代开发，完善功能，提高可靠性。 更新和完善 修改PID计算方法 此前的TCS算法中，PID调控方法是： 计算滑移率误差。滑移率误差Δs=0.2−s\\Delta s=0.2-sΔs=0.2−s 这里的计算方法就有问题。正确的误差为Δs=s−0.2\\Delta s=s-0.2Δs=s−0.2。因此得到的是滑移率误差的相反数 对滑移率误差应用PID算法，得到补偿扭矩 当滑移率较高时，PID得到的结果也较高，但是我们期望的是滑移率较高时，输出扭矩小，补偿扭矩应当为负。因此前面对滑移率误差取相反数后，PID的结果随之取反，滑移率越大，补偿扭矩越小（绝对值增大），理论上是正确的。 实际上这种方法非常反直觉，反人类，属于是屎山代码了。 将补偿扭矩与车手输入扭矩相加 这一步看起来是符合直觉的，实际上却不正确。对于正确的PID结果，应当为正值，我们期望减小输出扭矩，所以应当将补偿扭矩与车手输入扭矩相减。 修改后的PID算法如下 滑移率与滑移率目标相减，得到误差（高于目标为正），进入PID后，得到的补偿扭矩结果也为正。实际输出扭矩为车手输入扭矩减去补偿扭矩。即可实现PID调控效果。 这样的计算方式更加符合直觉，也符合PID调控结果一般为正值的习惯。 添加PID上下限 如上图所示，我在PID控制器上添加了外部控制的上下限，和重置信号。上下限是车手输入扭矩的±60%。重置信号来源于TCS的介入信号，下文会详细解释。 这里详细解释一下PID上下限的问题。为了避免人机对抗的情况发生，TCS的补偿扭矩不应高过车手的输入扭矩，保证车手时时刻刻都能掌握最高操纵权。实际运行中，让补偿扭矩控制在车手输入扭矩的±60%范围内，是一个既保证效果又保证安全的数值。尤其是当车手松开油门，扭矩为0时，TCS算法很难保证此时的输出就是0，因此存在车手松开油门，车辆仍然前进的情况。这样的情况十分危险。上下限按照车手输入扭矩进行动态调控后，如果车手松开油门，那么TCS的上下限也是0，TCS不会对车辆有任何干扰。 添加积分饱和和重置 当PID输出饱和时，如果不采取合适的抗饱和措施，PID控制器会一直累计积分项，导致比例项和微分项失去控制意义（被极大的积分项覆盖掉）。应用Clamp钳位的抗饱和方法，控制器会自动停止积分器积分，防止积分项过大影响控制器调控效果。 此外，每次TCS介入和退出，都不应包含上一次TCS算法的积分量。因此添加了一个积分重置信号，与TCS介入信号绑定，TCS介入瞬间，会将积分量清零。 PID参数 没仔细调。其实算法正确的情况下，PID不同的参数影响不大，都能实现较好的调控效果。 添加TCS介入和退出逻辑 此前的TCS算法只有一个总开关，只要开启，TCS始终都会进行计算和补偿。理想的TCS算法应当在需要的时候介入，不需要的时候，将操纵权交还给车手。这里我设计了一个简单的状态机。 同时满足以下三个条件时，TCS介入：滑移率≥0.2、车速≥0.5m/s、TCS尚未介入 以下任意一个条件满足时，若TCS已经介入，退出TCS：滑移率小于0.05、车速小于0.5m/s 添加这个逻辑后，如果直接应用到PID的结果上，容易导致输出扭矩剧烈跳动。比如TCS介入时，扭矩可能突然下降40~50，影响车手感知和电机寿命。因此，增加TCS介入和退出的平滑算法，利用Simulink的Rate Limiter实现。 TCS_EN信号是一个0-1跳变信号。添加Rate Limiter后，会变成一个上升/下降沿较缓的0-1跳变信号。这个信号与TCS算法结果相乘，即可对TCS算法进行开关或线性介入和退出。 车手输入扭矩曲线 利用1-D Lookup Table的特性，可以实现一个模仿车手油门输入的曲线。输入是仿真时间，输出是扭矩。改变曲线即可。 添加空气动力学模拟 Carsim中下压力的模拟非常简单。一张图就可以概括 三个方向的力，均受到各个方向的两个系数，和A、Q两个参数决定。Q会随着速度增加而增加。修改z方向的系数就可以修改下压力设定。 算法整体 算法效果 直线加速，模拟车手油门输入 摩擦力突变道路模拟","link":"/blog/2025/12/01/TCS%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E6%9B%B4%E6%96%B0/"},{"title":"Verilog八位总线制CPU设计","text":"前言 北京市大学生集成电路设计大赛刚刚结束，这篇推文记录一下为比赛所做的准备，尤其是针对数字组第三题八位总线制CPU的前期准备和赛场发挥。 题目描述 设计一个含通用寄存器的8位多功能总线处理器，由总线三态输入模块、寄存器控制模块、运算部分模块和控制电路模块构成。总线三态输入模块负责实现外部数据或寄存器数据向总线输送数据；寄存器控制模块负责将总线中的数据暂时存储到对应的寄存器；运算部分模块负责将暂存在A寄存器中的数据与总线中的数据，按照指定的加减法选择项进行运算并存储到G寄存器；控制电路模块则负责配合功能需求，按特定的节拍协调寄存器、运算器和总线控制所需的信号时序。 该通用寄存器的8位多功能总线处理器内部的R0-R3，A和G共6个寄存器，需要设计4种运算功能，分别是载数，转存，加法和减法运算。该通用寄存器的功能如下表所示。 操作 功能编码 执行的功能 含义 Load Rx,Data 00 Rx←Data 将外部数据送到指定的Rx寄存器 Move Rx,Ry 01 Rx←[Ry] 将Ry中的数据转存到Rx寄存器 ADD Rx,Ry 10 Rx←[Rx]+[Ry] 将Rx和Ry中的数据相加后送到Rx寄存器 SUB Rx,Ry 11 Rx←[Rx]-[Ry] 将Rx和Ry中的数据相减后送到Rx寄存器 总体思路 总线制的含义 总线制处理器，意味着所有的数据都要通过一根总线传输，听起来好像没什么大不了的，但是实际执行起来会困难重重。例如，ALU需要两个操作数才可以进行运算，但是在总线制CPU中，所有数据都要通过总线传输，意味着ALU至少需要2个周期才可以获取到两个操作数。同理，寄存器的输入和输出也必须通过总线，导致需要预留专门的周期供寄存器写入。再者，由于总线上挂载多种设备，如果逻辑分配不当，容易使得不同设备的输出同时接入总线，形成逻辑冲突。 状态机设计 根据这些特点和困难，我们首先考虑到各个模块的运行周期，设计状态机转换逻辑。可以确定的是，ALU需要两个周期，寄存器写入需要专门的一个周期，然后由于各种标志位的变化与状态机的变化延后一个周期，所以必须设计一个IDLE状态机才能满足时序要求。那么把这些要求综合到一起，可以发现至少需要一个四状态的状态机才能实现。 因此，我们设计四个状态机，分别起名为IDLE、TRANSFER、EXECUTE、WRITEBACK。他们的作用如下表 状态机 作用 IDLE 对指令进行解码，输出各种标志位 TRANSFER 传输ALU所需的第一个操作数 EXECUTE 传输ALU所需的第二个操作数，并同时进行ALU运算 WRITEBACK 将ALU的运算结果写入寄存器 总线判决机制 总线制的CPU，不同的模块必须同时挂在总线上，但是他们不能同时向总线输出数据，那样的话会导致总线上产生逻辑冲突，也就是总线的一方输出1，另一方输出0，产生冲突。因此，必须设计一个总线判决机制，使得同一时刻只有一个模块向总线输出，其他模块保持高阻态，从总线输入的模块原本就是高阻态，这样时时刻刻保持总线只有一个模块对其输出，就可以避免总线上产生逻辑冲突。 为了实现这个效果，每一个模块的输出都应该独立出来，不直接接到总线，而通过一个多路选择器（MUX）接到总线。MUX的原则就是只有一路输入接给输出，就可以保证总线只有一个模块对其输出。这部分最好在顶层模块中实现，因为顶层模块在实例化各个模块的时候，需要将他们的输出赋值给不同的wire，再将这些wire通过MUX连接给总线的wire。代码如下： 1234567assign bus = alu_out_en ? alu_out : extern_en ? Data : reg_out_en[0] ? reg_out_0 : reg_out_en[1] ? reg_out_1 : reg_out_en[2] ? reg_out_2 : reg_out_en[3] ? reg_out_3 : 8'bz; 这里bus就是总线，然后总线可以连接到不同的输出，每个输出都由一个en信号控制，且他们具有优先级。比如说，如果alu_out_en为1，那么就不再考虑extern_en和reg_out_en，直接将总线接给alu_out。 控制模块设计 为了给所有的模块提供控制信号，并且执行状态机转移逻辑，我们单独设计了一个控制模块。在控制模块中，首先要读取外部输入的Rx，Ry，Fun等信号，并据此给出alu_op等信号，然后根据clk，改变状态机，并根据状态机来决定很多模块的控制信号。 这一块代码比较复杂，是整个CPU最大的工作量，也是最容易出错的地方。 状态机转移 先前所说，我们的状态机有四个状态，分别叫做IDLE、TRANSFER、EXECUTE、WRITEBACK。这四个状态的转移，控制着整个CPU运行的节拍。正常情况下，每一个Clock的上升沿，状态机都会向下一个状态转移。因此，每四个时钟周期，就可以完成一个指令的执行。这些都是我们在准备过程中，假想的。因为我们认为，总线制CPU的极限就是四个时钟周期，不可能更快了，所以按照四个时钟周期一条指令进行计算，应当是比较充分的。 事实上，比赛时，组委会给出的Testbench，并不是四个时钟周期完成一个指令，而是可变的。由于我没法拿到组委会的原题，只能凭记忆描述一下。转成汇编的话，大概是这样子的。 123456LOAD R0,0x33LOAD R1,0x22LOAD R2,0x11ADD R0,R1MOVE R3,R0SUB R1,R2 Testbench中，最开始是三个LOAD指令，但是每两条指令之间只间隔了两个时钟周期。也就是说，6个时钟周期要完成3条指令。这与我们准备的完全不符了，而且最开始我们认为完全无法实现。赛场上碰到这个问题的时候，我们也是一脸懵，因为ALU至少需要两个时钟周期才能读取两个操作数，怎么可能两个周期就能执行完呢？ 但是，除了LOAD指令，其他的指令给的执行时间都很长，起码5、6个周期。按照4T的执行周期是能够完成的。整个执行过程，最耗时间的，其实就是ALU。这时候我们想到，其实LOAD指令根本不需要ALU，从总线读取，直接写入寄存器即可。那么，LOAD指令可以直接省去ALU转移数据所需要的两个时钟周期。所以，赛场上，我们最终的解决方案，是给LOAD指令设立特殊的转移流程，从IDLE直接转成IDLE，算上寄存器延时的一个周期，也就是两个时钟周期就可以完成。其他指令仍然四个时钟周期执行完。 控制信号 控制信号主要包括：外部输入控制、ALU输出控制、寄存器输出控制、ALU第一个操作数使能。这些控制信号都是根据操作码、操作数和状态机的组合逻辑产生的，只要穷举所有可能性就可以。因为可能性实在太多，所以代码很冗长，这里推荐大家先大致写一个逻辑，然后上Testbench跑，出现问题之后，定位出是哪个情况写错了/没考虑，然后再修改代码。这样得到的代码虽然比较屎山，但是对于竞赛来说，是一个又快又好的办法。 总结 这次的集电赛题跟我们赛前准备的内容非常相似，可以说准备到原题了，在这里记录下整个备赛的过程，既做留念，也留给后人学习。","link":"/blog/2025/06/02/Verilog%E5%85%AB%E4%BD%8D%E6%80%BB%E7%BA%BF%E5%88%B6CPU%E8%AE%BE%E8%AE%A1/"},{"title":"Vivado开发AM调制与相干解调算法","text":"这是一个学校安排的课设任务，要求是用Vivado实现DDS、AM调制、AM相干解调三部分功能。在这里记录一下有关AM调制解调的原理、思路和实现。 AM调制 AM——Amplitude Modulation——即为幅度调制。简单地说，就是将基波的幅度作为载波的幅度，把基波调制到载波上去。用数学方法表示为： m(t)=s(t)∗cos⁡(ωct)m(t)=s(t)*\\cos(\\omega_ct) m(t)=s(t)∗cos(ωc​t) 频谱上，等同于将原始信号的频谱双向搬移ωc\\omega_cωc​个单位长度，形成分别以±ωc\\pm\\omega_c±ωc​为中心对称分布的频谱。 （这里只考虑了基波为单极性的情况，双极性基波调制公式有所不同） AM解调 非相干解调 考虑一个实际的AM接收机，接收到了一个AM调制信号，长这个样子。 载波频率是1MHz，基波频率是100kHz。 最简单的解调方法是：包络检波。先进行整流，再进行滤波。整流后的信号和频谱分别为： 这个频谱可以看出来，通过一个低通滤波器可以轻松的去除掉高频分量，实现解调。解调后的波形带有一个直流分量，可以通过滑动平均或者高通滤波去除掉。 这种解调方式称为非相干解调，是因为这种方式不需要得到调制使用的载波，可以直接用调制波的特性进行解调。 相干解调 相干解调与非相干解调相对，是需要知道载波的频率、相位等信息才能进行解调的。基本原理如下。 首先，对一个信号乘以一个正弦/余弦信号，等同于将其频谱向两个方向搬移正弦/余弦频率个单位长度。 原始信号的频谱，是以ωc\\omega_cωc​为中心的两根对称谱线。如果再乘以一次ωc\\omega_cωc​的正弦信号，则会变成： 以0为中心的两根对称谱线（原频谱向中心搬移），幅值为原信号幅值的一半 以2ωc2\\omega_c2ωc​为中心的两根对称谱线（原频谱向两侧搬移），幅值为原信号幅值的四分之一 这时候，利用一个低通滤波器，滤除2ωc2\\omega_c2ωc​附近的频率分量，就可以完美的保留基带附近的频率分量，实现解调的效果。 IQ正交解调 IQ正交解调，我所看到的资料中，均划分到“相干解调”这一门类下。但是按照我的理解，IQ正交解调不需要获得载波信息。这个定义有待完善。 IQ正交解调的结构框图如下： 图源：https://www.cnblogs.com/SuperBigSaltFish0/p/18268057，以下大部分推导过程也参考此处。 设基带信号频率为ω1\\omega_1ω1​，载波频率为ω2\\omega_2ω2​，本振频率（解调时用的频率）为ω3\\omega_3ω3​ 先求I分量 I(t)=m(t)∗cos⁡(ω3t+ϕ3)=s(t)∗cos⁡(ω2t+ϕ2)∗cos⁡(ω3t+ϕ3)\\begin{aligned} I(t)&amp;=m(t)*\\cos(\\omega_3t+\\phi_3)\\\\ &amp;=s(t)*\\cos(\\omega_2t+\\phi_2)*\\cos(\\omega_3t+\\phi_3)\\\\ \\end{aligned} I(t)​=m(t)∗cos(ω3​t+ϕ3​)=s(t)∗cos(ω2​t+ϕ2​)∗cos(ω3​t+ϕ3​)​ 应用积化和差公式： I(t)=s(t)∗12[cos⁡((ω2+ω3)t+(ϕ2+ϕ3))+cos⁡((ω2−ω3)t+(ϕ2−ϕ3))]\\begin{aligned} I(t)&amp;=s(t)*\\frac{1}{2}[\\cos((\\omega_2+\\omega_3)t+(\\phi_2+\\phi_3))+\\cos((\\omega_2-\\omega_3)t+(\\phi_2-\\phi_3))]\\\\ \\end{aligned} I(t)​=s(t)∗21​[cos((ω2​+ω3​)t+(ϕ2​+ϕ3​))+cos((ω2​−ω3​)t+(ϕ2​−ϕ3​))]​ 同理可求得Q分量 Q(t)=s(t)∗12[sin⁡((ω2+ω3)t+(ϕ2+ϕ3))+sin⁡((ω2−ω3)t+(ϕ2−ϕ3))]\\begin{aligned} Q(t)&amp;=s(t)*\\frac{1}{2}[\\sin((\\omega_2+\\omega_3)t+(\\phi_2+\\phi_3))+\\sin((\\omega_2-\\omega_3)t+(\\phi_2-\\phi_3))]\\\\ \\end{aligned} Q(t)​=s(t)∗21​[sin((ω2​+ω3​)t+(ϕ2​+ϕ3​))+sin((ω2​−ω3​)t+(ϕ2​−ϕ3​))]​ 附：积化和差公式 cos⁡Acos⁡B=12[cos⁡(A+B)+cos⁡(A−B)]sin⁡Asin⁡B=12[cos⁡(A−B)−cos⁡(A+B)]sin⁡Acos⁡B=12[sin⁡(A+B)+sin⁡(A−B)]\\begin{aligned} \\cos A \\cos B &amp;= \\frac{1}{2} \\big[\\cos(A+B) + \\cos(A-B)\\big] \\\\ \\sin A \\sin B &amp;= \\frac{1}{2} \\big[\\cos(A-B) - \\cos(A+B)\\big] \\\\ \\sin A \\cos B &amp;= \\frac{1}{2} \\big[\\sin(A+B) + \\sin(A-B)\\big] \\end{aligned} cosAcosBsinAsinBsinAcosB​=21​[cos(A+B)+cos(A−B)]=21​[cos(A−B)−cos(A+B)]=21​[sin(A+B)+sin(A−B)]​ 暂时不考虑低通滤波，我把低通滤波放到了IQ求模之后。 令cos⁡(A)=cos⁡((ω2+ω3)t+(ϕ2+ϕ3))\\cos(A)=\\cos((\\omega_2+\\omega_3)t+(\\phi_2+\\phi_3))cos(A)=cos((ω2​+ω3​)t+(ϕ2​+ϕ3​))，cos⁡(B)=cos⁡((ω2−ω3)t+(ϕ2−ϕ3))\\cos(B)=\\cos((\\omega_2-\\omega_3)t+(\\phi_2-\\phi_3))cos(B)=cos((ω2​−ω3​)t+(ϕ2​−ϕ3​))，sin⁡\\sinsin与之同理。方便接下来的推导。 还原信号： sdemod(t)=I2(t)+Q2(t)=2s2(t)+14(cos⁡2(A)+sin⁡2(A))+14(cos⁡2(B)+sin⁡2(B))+12cos(A)cos(B)+12sin(A)sin(B)=2s2(t)+14(cos⁡2(A)+sin⁡2(A))+14(cos⁡2(B)+sin⁡2(B))+12cos⁡(A−B)=2s2(t)+12+12cos⁡(2ω3+2ϕ3)\\begin{aligned} s_{demod}(t)&amp;=\\sqrt{I^2(t)+Q^2(t)}\\\\ &amp;=\\sqrt{2s^2(t)+\\frac{1}{4}(\\cos^2(A)+\\sin^2(A))+\\frac{1}{4}(\\cos^2(B)+\\sin^2(B))+\\frac{1}{2}cos(A)cos(B)+\\frac{1}{2}sin(A)sin(B)}\\\\ &amp;=\\sqrt{2s^2(t)+\\frac{1}{4}(\\cos^2(A)+\\sin^2(A))+\\frac{1}{4}(\\cos^2(B)+\\sin^2(B))+\\frac{1}{2}\\cos(A-B)}\\\\ &amp;=\\sqrt{2s^2(t)+\\frac{1}{2}+\\frac{1}{2}\\cos(2\\omega_3+2\\phi_3)} \\end{aligned} sdemod​(t)​=I2(t)+Q2(t)​=2s2(t)+41​(cos2(A)+sin2(A))+41​(cos2(B)+sin2(B))+21​cos(A)cos(B)+21​sin(A)sin(B)​=2s2(t)+41​(cos2(A)+sin2(A))+41​(cos2(B)+sin2(B))+21​cos(A−B)​=2s2(t)+21​+21​cos(2ω3​+2ϕ3​)​​ 到这里，其实就能看出一些东西了。首先，sdemod(t)≈2s(t)s_{demod}(t)\\approx\\sqrt{2}s(t)sdemod​(t)≈2​s(t)，也就是说，不考虑直流分量和ω3\\omega_3ω3​分量，解调到这里就成功了。那也就是说，如果对该信号进行低通滤波和去直流处理，就能够还原出基带信号。这就是IQ解调的基本原理。其推导过程还是比较复杂的，但是可以看出，借助一个第三频率，可以去除掉原来的载波分量，保留基波分量。这对相干解调的硬件实现具有很重要的意义，相干解调不再需要获得与发射机同频同相的载波，对接收机的要求降低了很多。 Vivado搭建AM调制系统 从这里开始就没有什么技术含量了。我为了少写代码，基本上全都在用IP核，整个系统的搭建过程，就像在Simulink里面拿模块搭建一样。 DDS系统 直接调用了Vivado的DDS Compiler这一IP核。相关设置如下。 需要注意的是，DDS Compiler有两种设置模式，分别叫System Parameters和Hardware Parameters。在System Parameters模式下，用户输入的是动态范围、频率分辨率等需求参数，这些参数决定了DDS的外在表现，系统会根据这些需求自动计算出能够满足需求的DDS硬件参数。Hardware Parameters模式下，用户输入的是相位寄存器位宽、输出位宽等硬件参数，系统会计算出该参数下DDS的外在表现，显示在Summary页中。这两种DDS设置模式，可以适应不同系统的不同需求。 幅度调整 考虑到FPGA内部对浮点数的计算，并没有明显的优势，最好还是用整数运算实现整个系统。为了调节AM调制的调制度，又必须以小数比例调整幅度，例如本来255的峰峰值，为了实现0.3的调制度，必须用255×0.3=76.5的峰峰值。为了实现这个效果，我把基带信号先乘以33，再除以100，间接实现了小数乘法运算，也就实现了近似于0.3的调制比。 AM解调系统搭建 系统按照前文的系统框图搭建即可。不再赘述。 IQ求模运算，稍微写了一点Verilog代码，如下： 123456789101112131415161718192021module vector_norm( input clk, input signed [23:0] vec1, input signed [23:0] vec2, output [24:0] norm ); reg signed [47:0] out_reg; always @(posedge clk) begin out_reg &lt;= vec1 * vec1 + vec2 * vec2; end cordic_0 u_cordic ( .aclk (clk), .s_axis_cartesian_tvalid(1'b1), // 输入始终有效 .s_axis_cartesian_tdata(out_reg), // 输入数据 .m_axis_dout_tdata (norm) ); endmodule 记录一下FIR滤波器的设计。首先，FIR滤波器并没有内置分频器，Implementation Details里面的Input Frequency和Clock Frequency并不会直接改变clk的频率。例如，100MHz的系统里面，如果FIR想要以1MHz运行，必须把时钟一百分频之后输入FIR模块，单纯在FIR内部输入一个1MHz的Clock Frequency是不能让其正常工作的。Clock Frequency和Input Frequency我并没有搞明白他们的关系，按照网上的说法，二者必须相等，FIR才能运行。这一点在我的实验过程中得到了一定的验证，姑且认为必须这样吧。 其次，MATLAB滤波器想要生成coe文件，必须在左下角第三个按钮点开的页面里面，把系数格式从浮点数改为定点数。如下图所示。 系统仿真验证 AM调制波形如下： 70%调制度 100%调制度 AM解调波形如下：","link":"/blog/2025/09/16/Vivado%E5%BC%80%E5%8F%91AM%E8%B0%83%E5%88%B6%E4%B8%8E%E7%9B%B8%E5%B9%B2%E8%A7%A3%E8%B0%83%E7%AE%97%E6%B3%95/"},{"title":"WPF两轮车雷达上位机开发","text":"前言 开发两轮车雷达，调试过程中需要一个上位机程序，接收雷达传输的信息，显示在屏幕上，指示哪边来车。本篇博文将记录开发上位机的过程和遇到的问题 开发过程 窗体设置 添加串口和波特率设置 添加波特率和COM口选项123456789List&lt;int&gt; listOfBaudrate = new List&lt;int&gt;{ 2400, 4800, 9600, 19200, 38400, 57600, 115200};List&lt;string&gt; listOfPort = new List&lt;string&gt;(System.IO.Ports.SerialPort.GetPortNames());ComboBox_Port.ItemsSource = listOfPort;ComboBox_Port.SelectedIndex = 0;ComboBox_Baudrate.ItemsSource = listOfBaudrate;ComboBox_Baudrate.SelectedIndex = 6; 添加警示文字 把警示文字设置成不可见 后台程序 串口初始化12345678910111213141516private void SerialPortInit(){ try { serialPort = new SerialPort(); serialPort.PortName = ComboBox_Port.SelectedItem.ToString(); serialPort.BaudRate = (int)ComboBox_Baudrate.SelectedItem; serialPort.DataBits = 8; serialPort.StopBits = StopBits.One; serialPort.Parity = Parity.None; } catch(Exception ex) { MessageBox.Show(ex.Message); }} 串口开启与关闭函数 12345678910111213private void SerialPortOpen(){ SerialPortInit(); serialPort.Open(); serialPort.DataReceived += SerialPort_DataReceived;}private void SerialPortClose(){ serialPort.Close(); serialPort.Dispose(); serialPort = null;} 串口接收回调函数 由于接收回调函数是在另外一个线程调用的，不能直接修改GUI，需要用Dispathcer.Invoke()函数调用GUI线程。 此外，await可以进行一个异步等待，不影响GUI线程处理，本线程等待。借此实现一段时间后自动熄灭警示的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private async void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e){ int len = serialPort.BytesToRead; byte[] data = new byte[len]; serialPort.Read(data, 0, len); string str = Encoding.ASCII.GetString(data); try { if (str == &quot;Left&quot;) { Dispatcher.Invoke(() =&gt; { this.left.Visibility = Visibility.Visible; }); await Task.Delay(500); Dispatcher.Invoke(() =&gt; { this.left.Visibility = Visibility.Collapsed; }); } else if (str == &quot;Right&quot;) { Dispatcher.Invoke(() =&gt; { this.right.Visibility = Visibility.Visible; }); await Task.Delay(500); Dispatcher.Invoke(() =&gt; { this.right.Visibility = Visibility.Collapsed; }); } else { error.Visibility = Visibility.Visible; await Task.Delay(500); error.Visibility = Visibility.Collapsed; } } catch (Exception ex) { MessageBox.Show(ex.Message); }}","link":"/blog/2025/03/05/WPF%E4%B8%A4%E8%BD%AE%E8%BD%A6%E9%9B%B7%E8%BE%BE%E4%B8%8A%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91/"},{"title":"u8g2 mui进阶使用方法","text":"u8g2作为著名的OLED显示资源库，在嵌入式系统中有着广泛应用。但是，大多数人使用u8g2，往往局限于其基本功能，例如u8g2_DrawStr，u8g2_DrawLine等。如果想用u8g2做多级菜单，大多数人会额外编写很多代码或者引用另外一个库，却忽略了u8g2自带一个多级菜单库——mui。网络上对mui的介绍少之又少，这里我结合最近的一个项目，详细介绍一下mui的用法，并且扩展一些进阶用法，实现更加复杂的功能。 开发环境 我在STM32上移植了u8g2的所有库，使用Keil MDK+STM32CubeMX共同开发。使用的OLED是SSD1306，通过i2C接口与之相连，IIC速率为400kbps。为了减少CPU占用，尽可能使用DMA方式传输OLED数据。 u8g2使用 u8g2的使用方法，网上介绍的已经很多了。移植重点分为以下几点： 把所有.c文件加入Keil MDK中 选择合适的初始化函数，并注释掉其余函数。我选择的是u8g2_Setup_ssd1306_128x64_noname_f 选择合适的缓存函数，并注释掉其余函数。初始化函数中，只调用了u8g2_m_16_8_f这一个缓存函数，因此注释掉其他的。 编写u8x8_gpio_and_delay函数和u8x8_byte_xxx函数。如果是硬件IIC/SPI，则需要自己编写后者，否则可以使用u8g2自带的软件IIC和SPI函数。 本篇博文重点在于mui的使用，因此不再赘述。 mui使用 mui介绍 官方Github介绍，mui是u8g2的一个小插件，目的是方便用u8g2创建一个能够与用户交互的界面。对于嵌入式应用来说，它体量很小，适合用在嵌入式系统中。当然，体量小意味着开发起来是有一定难度的。好在mui内置的界面组件够多，能够满足简单的需求，因此学会了之后，用起来还是挺方便的。 mui与u8g2是共同使用的，必须先把u8g2调通了之后，再开发mui。 mui的菜单界面、功能主要由两个东西决定，分别叫做MUIF和FDS。我们先把两个名词弄清楚。MUIF即MUI Function，决定了一个UI组件的所有功能（包括绘制！！！），与组件的位置、排布等无关。FDS即“Form Definition String”，决定了UI组件的排列、页面布局等设计内容，与功能关系不大。 MUIF介绍 MUIF决定了组件的功能。它的组成方式，与word中的样式很相似。一个MUIF可以对应多个组件，这些组件的功能是一样的，类似于word中，不同段落的文字，只要是同一个样式，那么格式就是一样的。 有关MUIF。我举几个例子。 假设一个Label类型的组件，他不能直接显示在屏幕上，想要把它写在屏幕上，需要调用对应的MUIF，MUIF调用u8g2的函数，使其显示在屏幕上。但是，Label的内容不是MUIF决定的。Label的内容对MUIF来说，就是一个函数参数，直接传给u8g2显示出来而已。 假设一个Button类型的组件，他的显示与Label相同，需要调用MUIF。同时，它的按下、抬起等交互功能，也需要调用MUIF实现。比如，按下跳转到另一个页面，本质上是按下按钮后，调用mui_SendSelect，让mui知道按钮被按下了。mui就会寻找这个按钮的MUIF，调用MUIF中的有关按钮按下的代码，实现用户需要的各种功能。 假设有两个Button位于同一页面，一个是跳转到下一页面，一个是返回上一页面。他俩的功能是不一样的，因此，他俩应该使用不同的MUIF。每个MUIF都有一个独特的、自定义的ID，不同按钮的可以选择不同的ID，即对应到不同的MUIF。 假设两个Button，功能相同，都是跳转页面，但是两个按钮跳转到不同的页面。那么他们应当调用同一个MUIF，即使用同一个ID。只不过给MUIF的参数不同，跳转页面1，就传入1，跳转页面2，就传入2。 这几个例子，我觉得能够把MUIF的作用解释清楚了。 下面我们实际看一个MUIF如何设计。这是一个mui内置的MUIF，能够实现常见的按下跳转功能。 1234567891011121314151617181920212223242526272829uint8_t mui_u8g2_btn_goto_wm_fi(mui_t *ui, uint8_t msg){ switch(msg) { case MUIF_MSG_DRAW: mui_u8g2_draw_button_utf(ui, U8G2_BTN_HCENTER |mui_u8g2_get_fi_flags(ui), 0, 1, MUI_U8G2_V_PADDING, ui-&gt;text); break; case MUIF_MSG_FORM_START: break; case MUIF_MSG_FORM_END: break; case MUIF_MSG_CURSOR_ENTER: break; case MUIF_MSG_CURSOR_SELECT: case MUIF_MSG_VALUE_INCREMENT: case MUIF_MSG_VALUE_DECREMENT: //return mui_GotoForm(ui, ui-&gt;arg, 0); mui_SaveForm(ui); return mui_GotoFormAutoCursorPosition(ui, ui-&gt;arg); case MUIF_MSG_CURSOR_LEAVE: break; case MUIF_MSG_TOUCH_DOWN: break; case MUIF_MSG_TOUCH_UP: break; } return 0;} 可以看到，MUIF是以msg为框架的。不同的msg会对应到不同的代码。如果输入一个MUIF_MSG_DRAW，那么mui_u8g2_draw_button_utf这个函数就会被调用，从而在屏幕上绘制一个按钮出来。 我们常用的msg是MUIF_MSG_CURSOR_SELECT，即按钮按下事件。现在这个MUIF里面，设计的是按下后，保存当前表单，跳转到另一个表单。 进阶用法1 假设，我们需要，按下按钮后，让某一个变量+1，然后跳转到另一个表单，怎么做呢？ 123456789101112uint8_t variable;uint8_t mui_u8g2_btn_add_goto_wm_fi(mui_t *ui, uint8_t msg){ switch(msg) { case MUIF_MSG_CURSOR_SELECT: variable++; default: return mui_u8g2_btn_goto_wm_fi(ui, msg); }} 自己定义一个函数，这个函数也仿照内置的MUIF编写，对msg进行switch，如果msg是MUIF_MSG_CURSOR_SELECT，那么就让variable自增。而且，自增完后，因为没加break，他还会调用本来的MUIF，实现跳转功能。除了MUIF_MSG_CURSOR_SELECT以外的msg，也会直接进入default，让本来的MUIF进行处理。我们只需要添加“按下按钮变量+1”的功能，因此只需要修改msg是MUIF_MSG_CURSOR_SELECT时的代码，其他的都可以交给原来的MUIF进行处理。 构造好想要的MUIF函数之后，就可以构造一个MUIF数组，与FDS建立关联。仍然是举个例子 12345muif_t muif_list[] = { MUIF_U8G2_FONT_STYLE(0, u8g2_font_helvR08_tr), /* define style 0 */ MUIF_U8G2_LABEL(), /* allow MUI_LABEL macro */ MUIF_BUTTON(&quot;BN&quot;, mui_u8g2_btn_add_goto_wm_fi) /* define exit button */}; 这个muif_list首先定义了一个字体样式，样式ID为0，字体为u8g2_font_helvR08_tr。启用MUI_LABEL这一FDS描述符。定义了一个按钮样式，样式ID为&quot;BT&quot;，样式的回调函数是mui_u8g2_btn_add_goto_wm_fi。这样一个MUIF就把很多特性全部定义好了。只要是ID为&quot;BT&quot;的组件，都会按照这个MUIF定义的功能执行。只要是ID为0的字体，都使用u8g2_font_helvR08_tr这个字体。 这里需要澄清一下两个ID的关系。一种ID是两位字符型变量。例如&quot;BT&quot;。这个ID与我们平时理解的数字ID，有显著区别。另一个ID是一个8位无符号二进制数，用在Form的ID、字体样式的ID等地方。这就限制了mui最多可以定义255个字体、255个表单，字体选择、表单之间的跳转也是根据ID进行的。 FDS介绍 FDS我认为是mui中比较败笔的一个部分，虽然能够实现功能，但是实现起来太难理解、维护困难、代码冗长、逻辑混乱。 FDS是一个字符串，不能把它理解为数组。为FDS初始化时，不能在两个macro之间加逗号，必须紧连着，实现一个连续不断的字符串的效果。 12345fds_t fds_data[] = MUI_FORM(1) // no comma allowed, because fds_data is a string MUI_STYLE(0) MUI_XYT(&quot;BN&quot;,64, 30, &quot; Select Me &quot;); 这样一个FDS字符串定义了一个表单（Form）。表单就是我们日常理解的页面，跳转到另一个表单，就是跳转到另一个页面。这个FDS只定义了一个Form。MUI_STYLE(0)代表了使用第0号字体，MUI_XYT定义了一个具有横坐标，纵坐标，内部文字三个属性的元素，且该元素使用ID为“BN”的MUIF。 FDS直接决定页面布局。定义了上述这一个FDS后，第一个页面中，就会在(64,30)的地方出现一个元素，内部有“Select Me”文字。不过，这个元素的外貌并不取决于FDS，而是取决于MUIF中，msg为MUIF_MSG_DRAW时的回调函数。这个回调函数画出来的就是这个元素的外貌。FDS决定了位置、文字和可能的参数（使用MUI_XYA或MUI_XYAT时可以定义参数，参数一般都是跳转目标页面号）。 进阶用法2 显然，FDS很难被修改。这就导致mui生成的多级菜单比较固定，很难做到动态修改菜单内容。不过，这一点官方也提供了一种解决方法。先看代码。下面这段代码来自于[https://github.com/olikraus/u8g2/wiki/muiref#scrollable-jump-table-dynamic] 1234567891011121314151617181920212223242526272829303132333435uint16_t menu_get_cnt(void *data) { return 10; /* number of menu entries */}const char *menu_get_str(void *data, uint16_t index) { static const char *menu[] = { MUI_1 &quot;Goto Main Menu&quot;, MUI_10 &quot;Enter a number&quot;, MUI_11 &quot;Parent/Child Selection&quot;, MUI_13 &quot;Checkbox&quot;, MUI_14 &quot;Radio Selection&quot;, MUI_15 &quot;Text Input&quot;, MUI_16 &quot;Single Line Selection&quot;, MUI_17 &quot;List Line Selection&quot;, MUI_18 &quot;Parent/Child List&quot;, MUI_20 &quot;Array Edit&quot;, }; return menu[index];}uint16_t selection = 0;muif_t muif_list[] = { MUIF_U8G2_FONT_STYLE(0, u8g2_font_helvR08_tr), /* define style 0 */ MUIF_U8G2_LABEL(), MUIF_U8G2_U16_LIST(&quot;ID&quot;, &amp;selection, NULL, menu_get_str, menu_get_cnt, mui_u8g2_u16_list_goto_w1_pi),};fds_t fds_data[] = MUI_FORM(3) MUI_STYLE(0) MUI_XYA(&quot;ID&quot;, 5, 25, 0) MUI_XYA(&quot;ID&quot;, 5, 37, 1) MUI_XYA(&quot;ID&quot;, 5, 49, 2) MUI_XYA(&quot;ID&quot;, 5, 61, 3) ; 代码实现的核心，是一个叫做MUIF_U8G2_U16_LIST的MUIF。这个函数具体的实现我也不懂，不过借助这个函数可以构造出一个可滚动列表，由于FDS定义了四个该ID的对象，因此这个列表只会显示四个元素，元素会随着滚动而变化。如果元素数量小于四，程序也会自动禁用滚动功能。所以只要改变这个列表，就可以改变菜单的元素。官方的menu_get_cnt和menu_get_str实现了动态获取列表长度和列表元素的功能。虽然官方给的这俩函数，返回值是固定的，但是放到自己的项目上，只要满足返回值的规则，可以自己随意的修改这个函数，来返回自己想要显示在屏幕上的内容。 menu_get_str返回的字符串可以拆分为两部分，第一个字节所代表的数字，是这一行按下后会跳转到的目标表单序号。第一个字节后的内容，就是该行的显示文字。这里一定要注意，目标表单序号是字符串的第一个字节，以二进制数的形式存储，而不是字符形式（ASCII码）。 下面我举一个例子，把一个链表的所有元素显示到屏幕上。这里只实现menu_get_cnt和menu_get_str两个函数，FDS和MUIF与上面的代码相同。 12345678910111213141516171819202122232425262728// 定义链表数据结构体typedef struct { char str[32]; node_t *next;} node_t;extern node_t *head;/* 假设已经实现了 uint32_t List_GetLength(node_t* head); char* List_GetStr(node_t* head, uint32_t index);*/uint16_t menu_get_cnt(void *data) { return List_GetLength(head); /* number of menu entries */}const char *menu_get_str(void *data, uint16_t index) { // 必须定义成静态变量，因为该变量会以指针的形式返回到函数外 static char str[32]; // 假设第一个按钮跳转到1号表单，第二个按钮跳转到2号表单。向第一个元素写入表单ID str[0] = index+1; // 从str的第二个元素开始，把链表字符串复制到str中。 strcpy(str+1, (const char*)List_GetStr(head, index)); // 返回str指针 return (const char*)str;} 每次调用menu_get_str函数时，都会返回对应的链表的字符串。随着链表的修改，增加，删除，得到的字符串和总长度也会随之变化，这样就实现了一个符合自己需求的动态菜单。 结语 mui作为一个伴随u8g2出现的轻量级多级菜单库，它的功能已经远超我的预期，配合自己编写的回调函数，能够满足绝大多数的需求。但是，轻量化所带来的抽象，使得理解和编写代码变得困难。本文算是填补了网络上有关mui的空白，尤其是介绍了重写mui回调函数的基本方法，实现mui与已有项目的良好融合。","link":"/blog/2025/10/15/u8g2%20mui%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"信号与系统复习资料","text":"信号与系统知识点和例题梳理 整理了一小部分知识点，和我自己学的不太扎实的题型。 信号的描述及分类 确定信号与随机信号 连续信号与离散信号 连续 冲激信号δ(t)\\delta(t)δ(t) 信号大小一定要加括号 筛选特性：x(t)δ(t−t0)=x(t0)δ(t−t0)x(t)\\delta(t-t_0)=x(t_0)\\delta(t-t_0)x(t)δ(t−t0​)=x(t0​)δ(t−t0​)，若结果含有x(t)δ(t)x(t)\\delta(t)x(t)δ(t)，必须化简一步。 抽样特性：∫∞∞x(t)δ(t−t0)=x(t0)\\int_{\\infty}^{\\infty}x(t)\\delta(t-t_0)=x(t_0)∫∞∞​x(t)δ(t−t0​)=x(t0​) 展缩特性：δ(at)=1∣a∣δ(t)\\delta(at)=\\frac{1}{|a|}\\delta(t)δ(at)=∣a∣1​δ(t) 阶跃信号u(t)u(t)u(t) 不考虑t=0t=0t=0的值（该处的函数值没有定义） 斜坡信号r(t)r(t)r(t) 离散 冲激信号δ[k]\\delta[k]δ[k] 注意在k=0k=0k=0时函数值为1，而不是正无穷。标的时候不能加括号。 δ[ak]=δ[k]\\delta[ak]=\\delta[k]δ[ak]=δ[k]，这点与连续的冲激函数不同。 阶跃信号u[k]u[k]u[k] k=0k=0k=0时，函数值确定为1。 斜坡信号r[k]r[k]r[k] 周期信号与非周期信号 连续 定义：∀x∈R\\forall x \\in R∀x∈R，存在正实数TTT，使得x(t+nT)=x(t)x(t+nT)=x(t)x(t+nT)=x(t)成立。则TTT是x(t)x(t)x(t)的周期。 最小正实数T0T_0T0​称为基本周期 正弦信号x(t)=Asin⁡(ω0t+θ)x(t)=A\\sin(\\omega_0 t+\\theta)x(t)=Asin(ω0​t+θ)的周期为： T0=2π∣ω0∣T_0 = \\frac{2\\pi}{|\\omega_0|} T0​=∣ω0​∣2π​ 离散 定义：∀k∈Z\\forall k \\in Z∀k∈Z，存在正整数NNN，使得x[k+nN]=x[k]x[k+nN]=x[k]x[k+nN]=x[k]成立。则NNN是x[k]x[k]x[k]的周期。 最小正实数N0N_0N0​称为基本周期 离散正弦信号x[k]=sin⁡(Ω0k)x[k] = \\sin(\\Omega_0k)x[k]=sin(Ω0​k)不一定是周期信号！ 若∣Ω0∣2π=mN\\frac{|\\Omega_0|}{2\\pi}=\\frac{m}{N}2π∣Ω0​∣​=Nm​为有理数（mmm和NNN都为不可约的正整数），则NNN为信号的周期。 虚指数序列ejΩ0ke^{j\\Omega_0k}ejΩ0​k的周期计算方法相同。 例：求下列离散序列的周期 (1)x[k]=sin⁡(π5)x[k] = \\sin(\\frac{\\pi}{5})x[k]=sin(5π​) 解： ∣Ω0∣2π=110\\frac{|\\Omega_0|}{2\\pi}=\\frac{1}{10} 2π∣Ω0​∣​=101​ 则周期为10 (2)x[k]=sin⁡(4π11)x[k] = \\sin(\\frac{4\\pi}{11})x[k]=sin(114π​) 解： ∣Ω0∣2π=110\\frac{|\\Omega_0|}{2\\pi}=\\frac{1}{10} 2π∣Ω0​∣​=101​ 则周期为10 (3)以T=0.4T=0.4T=0.4抽样间隔对连续信号sin(t)sin(t)sin(t)抽样得到的离散信号 解： sin(t)∣t=kT=sin(0.4k)sin(t)|_{t=kT}=sin(0.4k) sin(t)∣t=kT​=sin(0.4k) ∣Ω0∣2π=15π\\frac{|\\Omega_0|}{2\\pi}=\\frac{1}{5\\pi} 2π∣Ω0​∣​=5π1​ 为无理数，所以不是周期信号 能量信号和功率信号 归一化能量有限的称为能量信号 归一化功率有限的称为功率信号 例：判断下列信号是能量信号还是功率信号 （1）x(t)=Ae−tx(t)=Ae^{-t}x(t)=Ae−t 解：归一化能量 ∫−∞+∞∣Ae−t∣2=−2A2e−2t∣−∞+∞=∞\\int_{-\\infty}^{+\\infty}|Ae^{-t}|^2=-2A^2e^{-2t}|_{-\\infty}^{+\\infty}=\\infty ∫−∞+∞​∣Ae−t∣2=−2A2e−2t∣−∞+∞​=∞ 归一化功率 lim⁡T→∞(12T∫−TT∣Ae−t∣2)=lim⁡T→∞(−2A2e−2t∣−TT)=∞\\lim_{T\\rightarrow\\infty}(\\frac{1}{2T}\\int_{-T}^{T}|Ae^{-t}|^2)=\\lim_{T\\rightarrow\\infty}(-2A^2e^{-2t}|_{-T}^{T})=\\infty T→∞lim​(2T1​∫−TT​∣Ae−t∣2)=T→∞lim​(−2A2e−2t∣−TT​)=∞ 既不是能量信号，也不是功率信号 （2）x[k]=(45)k,k≥0x[k]=(\\frac{4}{5})^k,k\\ge 0x[k]=(54​)k,k≥0 解：归一化能量 lim⁡N→∞∑k=−NN∣x[k]∣2=lim⁡N→∞∑k=0N(45)2k=11−0.64\\lim_{N\\rightarrow\\infty}\\sum_{k=-N}^{N}|x[k]|^2=\\lim_{N\\rightarrow\\infty}\\sum_{k=0}^{N}(\\frac{4}{5})^{2k}=\\frac{1}{1-0.64} N→∞lim​k=−N∑N​∣x[k]∣2=N→∞lim​k=0∑N​(54​)2k=1−0.641​ 归一化功率 lim⁡N→∞12N+1∑k=−NN∣x[k]∣2=lim⁡N→∞12N+1∑k=0N(45)2k\\lim_{N\\rightarrow\\infty}\\frac{1}{2N+1}\\sum_{k=-N}^{N}|x[k]|^2=\\lim_{N\\rightarrow\\infty}\\frac{1}{2N+1}\\sum_{k=0}^{N}(\\frac{4}{5})^{2k} N→∞lim​2N+11​k=−N∑N​∣x[k]∣2=N→∞lim​2N+11​k=0∑N​(54​)2k =lim⁡N→∞11−0.642N+1=0=\\lim_{N\\rightarrow\\infty}\\frac{\\frac{1}{1-0.64}}{2N+1}=0 =N→∞lim​2N+11−0.641​​=0 是能量信号，也是功率信号（能量信号一定是功率信号） 系统的描述及分类 系统的描述 输入输出描述 状态变量描述 系统的分类和判断 离散、连续 显而易见 线性非线性 均匀特性 若Tx(t)=y(t)T{x(t)}=y(t)Tx(t)=y(t)，则T(kx(t))=ky(t)T(kx(t))=ky(t)T(kx(t))=ky(t) 输入翻倍，输出也翻倍。 叠加特性 若T{x1(t)}=y1(t)T\\{x_1(t)\\}=y_1(t)T{x1​(t)}=y1​(t)，T{x2(t)}=y2(t)T\\{x_2(t)\\}=y_2(t)T{x2​(t)}=y2​(t)，则T{x1(t)+x2(t)}=y1(t)+y2(y)T\\{x_1(t)+x_2(t)\\}=y_1(t)+y_2(y)T{x1​(t)+x2​(t)}=y1​(t)+y2​(y) 输入相加，输出也相加。 综合表示 若T{x1(t)}=y1(t)T\\{x_1(t)\\}=y_1(t)T{x1​(t)}=y1​(t)，T{x2(t)}=y2(t)T\\{x_2(t)\\}=y_2(t)T{x2​(t)}=y2​(t)，则T{αx1(t)+βx2(t)}=αy1(t)+βy2(y)T\\{\\alpha x_1(t)+\\beta x_2(t)\\}=\\alpha y_1(t)+\\beta y_2(y)T{αx1​(t)+βx2​(t)}=αy1​(t)+βy2​(y) 输入线性组合，输出也线性组合。 零输入和零状态线性 含有初始状态的系统，若系统的响应可以分解为零输入和零状态，则需要分别求线性。只要两部分都线性，系统就线性。 若系统的响应不可以被分解为零输入和零状态（例如：y[k]=4y[0]⋅x[k]+3x[k]y[k]=4y[0]·x[k]+3x[k]y[k]=4y[0]⋅x[k]+3x[k]），则一定不线性，因为初始状态不会受输入影响，输入线性组合不会改变初始状态，也就无法使得输出线性组合。 例：判断该系统是否为线性系统 （1）y(t)=y(0)sin(2t)+∫0tx(τ)dτy(t)=y(0)sin(2t)+\\int_{0}^{t}x(\\tau)d\\tauy(t)=y(0)sin(2t)+∫0t​x(τ)dτ 解： yzs(t)=∫0tx(τ)dτy_{zs}(t)=\\int_{0}^{t}x(\\tau)d\\tau yzs​(t)=∫0t​x(τ)dτ yzi(t)=y(0)sin(2t)y_{zi}(t)=y(0)sin(2t) yzi​(t)=y(0)sin(2t) Tzs{αx1(t)+βx2(t)}=∫0tαx1(τ)+βx2(τ)dτT_{zs}\\{\\alpha x_1(t)+\\beta x_2(t)\\}=\\int_{0}^{t}\\alpha x_1(\\tau)+\\beta x_2(\\tau)d\\tau Tzs​{αx1​(t)+βx2​(t)}=∫0t​αx1​(τ)+βx2​(τ)dτ αyzs1(t)+βyzs2(t)=α∫0tx1(τ)+β∫0tx2(τ)dτ\\alpha y_{zs1}(t)+\\beta y_{zs2}(t)=\\alpha\\int_{0}^{t} x_1(\\tau)+\\beta\\int_{0}^{t} x_2(\\tau)d\\tau αyzs1​(t)+βyzs2​(t)=α∫0t​x1​(τ)+β∫0t​x2​(τ)dτ 输入线性组合的响应与输出线性组合相等，具有零状态线性 Tzi{αy1(0)+βy2(0)}=[αy1(0)+βy2(0)]sin⁡(2t)T_{zi}\\{\\alpha y_1(0)+\\beta y_2(0)\\}=[\\alpha y_1(0)+\\beta y_2(0)]\\sin(2t) Tzi​{αy1​(0)+βy2​(0)}=[αy1​(0)+βy2​(0)]sin(2t) αyzi1(t)+βyzi2(t)=αy1(0)sin⁡(2t)+βy2(0)sin⁡(2t)\\alpha y_{zi1}(t)+\\beta y_{zi2}(t)=\\alpha y_1(0)\\sin(2t)+\\beta y_2(0)\\sin(2t) αyzi1​(t)+βyzi2​(t)=αy1​(0)sin(2t)+βy2​(0)sin(2t) 初始状态线性组合的响应与输出线性组合相等，具有零输入线性 综上，该系统具有线性 （2）y[k]=2y[0]+6x2[k]y[k]=2y[0]+6x^2[k]y[k]=2y[0]+6x2[k] 解：零输入响应yzi[k]=2y[0]y_{zi}[k]=2y[0]yzi​[k]=2y[0]，显然线性 yzs[k]=6x2[k]y_{zs}[k]=6x^2[k] yzs​[k]=6x2[k] Tzs{αx1[k]+βx2[k]}=6α2x12[k]+12αβx1[k]x2[k]+6β2x22[k]T_{zs}\\{\\alpha x_1[k]+\\beta x_2[k]\\}=6\\alpha^2x_1^2[k]+12\\alpha\\beta x_1[k]x_2[k]+6\\beta^2x_2^2[k] Tzs​{αx1​[k]+βx2​[k]}=6α2x12​[k]+12αβx1​[k]x2​[k]+6β2x22​[k] αyzi1[k]+βyzi2[k]=6α2x12[k]+6β2x22[k]\\alpha y_{zi1}[k]+\\beta y_{zi2}[k]=6\\alpha^2x_1^2[k]+6\\beta^2x_2^2[k] αyzi1​[k]+βyzi2​[k]=6α2x12​[k]+6β2x22​[k] 二者并不相等，所以不具有零状态线性。 综上，该系统不具有线性 时变非时变 定义：非时变系统中，若x(t)x(t)x(t)产生的输出为y(t)y(t)y(t)，则输入x(t−t0)x(t-t_0)x(t−t0​)产生的输出必为y(t−t0)y(t-t_0)y(t−t0​)。离散同理。 LTI系统 具有线性和非时变性的系统成为线性非时变系统（Linear Time-Invariant System）。 积分（求和）特性 输入积分，输出也积分。 微分（差分）特性 输入微分，输出也微分。 这些特性可以用来根据已知的激励和响应，求线性组合、微分积分的激励产生的响应 因果非因果 任意时刻的输出，都不超前于系统的输入。 例如：y[k]=2x[k+1]y[k]=2x[k+1]y[k]=2x[k+1]，0时刻的输出由1时刻的输入决定，超前于输入，因此不是因果系统。 用单位冲激响应判断（只适用于LTI系统） 因果系统的 H(s)H(s)H(s) ，则其收敛域为 Re(s)&gt;σ0\\text{Re}(s) &gt; \\sigma_0Re(s)&gt;σ0​（某个右半平面）。 因果离散系统，ROC 是以原点为中心某个圆周的外侧区域（即 ∣z∣&gt;r0|z| &gt; r_0∣z∣&gt;r0​） 方法 连续系统 离散系统 冲激响应 h(t)=0, t&lt;0h(t)=0,\\ t&lt;0h(t)=0, t&lt;0 h[k]=0, k&lt;0h[k]=0,\\ k&lt;0h[k]=0, k&lt;0 复频域收敛域 sss收敛域包括右半平面 zzz收敛域为某一圆外 稳定非稳定 任意有界的输入，其输出都是有界的。例如：∫−∞tx(τ)dτ\\int_{-\\infty}^{t}x(\\tau)d\\tau∫−∞t​x(τ)dτ，输入为阶跃信号时，t→∞t\\rightarrow\\inftyt→∞时，输出是无穷，不满足条件。不具有BIBO稳定性。 单位冲激响应判断（只适用于LTI系统） 在复频域，连续时间LTI系统具有BIBO稳定性的充要条件是系统函数H(s)H(s)H(s)的收敛域包含sss平面的虚轴，即收敛域Re(s)&gt;σ0Re(s)&gt;\\sigma_0Re(s)&gt;σ0​且σ0&lt;0\\sigma_0&lt;0σ0​&lt;0。 在复频域，离散时间LTI系统具有BIBO稳定性的充要条件是系统函数H(z)H(z)H(z)的收敛域包含zzz平面的单位圆，即∣z∣&lt;r0|z|&lt;r_0∣z∣&lt;r0​且r0&gt;1r_0&gt;1r0​&gt;1。 信号的基本运算 时域信号，所有的操作都是对自变量t或者x，而不是对括号内的整体。 先时移，再翻转/压缩/扩展 翻转 压缩/扩展 时移 例： 卷积 连续 x(t)∗h(t)=∫−∞+∞x(τ)h(t−τ)dτx(t)*h(t)=\\int_{-\\infty}^{+\\infty}x(\\tau)h(t-\\tau)d\\tau x(t)∗h(t)=∫−∞+∞​x(τ)h(t−τ)dτ 例：求x(t)∗h(t)x(t)*h(t)x(t)∗h(t) (1)x(t)=e−tu(t),h(t)=e−2tu(t−2)x(t)=e^{-t}u(t),h(t)=e^{-2t}u(t-2)x(t)=e−tu(t),h(t)=e−2tu(t−2) 后面整理的比较仓促。 傅里叶变换性质 序号 性质名称 时域表达x(t)x(t)x(t) 频域表达X(jω)X(j\\omega)X(jω) 说明 1 线性性 ax1(t)+bx2(t)ax_1(t)+bx_2(t)ax1​(t)+bx2​(t) aX1(jω)+bX2(jω)aX_1(j\\omega)+bX_2(j\\omega)aX1​(jω)+bX2​(jω) 傅里叶变换是线性运算 2 时移性质 x(t−t0)x(t-t_0)x(t−t0​) X(jω)e−jωt0X(j\\omega)e^{-j\\omega t_0}X(jω)e−jωt0​ 时间延迟对应频域相位变化 3 频移性质 x(t)ejω0tx(t)e^{j\\omega_0t}x(t)ejω0​t X(j(ω−ω0))X(j(\\omega-\\omega_0))X(j(ω−ω0​)) 调制使频谱移动 4 缩放性质 x(at)x(at)x(at) 1aX(jωa)\\frac{1}{a}X\\left(j\\frac{\\omega}{a}\\right)a1​X(jaω​) 时间伸缩对应频率反向伸缩 5 微分性质 dnx(t)dtn\\frac{d^nx(t)}{dt^n}dtndnx(t)​ (jω)nX(jω)(j\\omega)^nX(j\\omega)(jω)nX(jω) 导数变乘频率项 6 积分性质 ∫−∞tx(τ) dτ\\int_{-\\infty}^{t}x(\\tau)\\,d\\tau∫−∞t​x(τ)dτ 1jωX(jω)+πX(0)δ(ω)\\frac{1}{j\\omega}X(j\\omega)+\\pi X(0)\\delta(\\omega)jω1​X(jω)+πX(0)δ(ω) 时间积分对应频域除以jωj\\omegajω 7 卷积性质 x1(t)∗x2(t)x_1(t)*x_2(t)x1​(t)∗x2​(t) X1(jω)⋅X2(jω)X_1(j\\omega)\\cdot X_2(j\\omega)X1​(jω)⋅X2​(jω) 时域卷积对应频域乘法 8 乘积性质 x1(t)⋅x2(t)x_1(t)\\cdot x_2(t)x1​(t)⋅x2​(t) 12πX1(jω)∗X2(jω)\\frac{1}{2\\pi}X_1(j\\omega)*X_2(j\\omega)2π1​X1​(jω)∗X2​(jω) 时域乘法对应频域卷积 常见傅里叶变换对 原始信号 x(t)x(t)x(t) 傅里叶变换 X(jω)X(j\\omega)X(jω) cos⁡(ω0t)\\cos(\\omega_0 t)cos(ω0​t) π[δ(ω−ω0)+δ(ω+ω0)]\\pi[\\delta(\\omega - \\omega_0) + \\delta(\\omega + \\omega_0)]π[δ(ω−ω0​)+δ(ω+ω0​)] sin⁡(ω0t)\\sin(\\omega_0 t)sin(ω0​t) jπ[δ(ω+ω0)−δ(ω−ω0)]j\\pi[\\delta(\\omega + \\omega_0) - \\delta(\\omega - \\omega_0)]jπ[δ(ω+ω0​)−δ(ω−ω0​)] δ(t)\\delta(t)δ(t) 111 δ(t−t0)\\delta(t - t_0)δ(t−t0​) e−jωt0e^{-j\\omega t_0}e−jωt0​ u(t)u(t)u(t) πδ(ω)+1jω\\pi\\delta(\\omega) + \\frac{1}{j\\omega}πδ(ω)+jω1​ cos⁡(ω0t)\\cos(\\omega_0 t)cos(ω0​t) π[δ(ω−ω0)+δ(ω+ω0)]\\pi[\\delta(\\omega - \\omega_0) + \\delta(\\omega + \\omega_0)]π[δ(ω−ω0​)+δ(ω+ω0​)] sin⁡(ω0t)\\sin(\\omega_0 t)sin(ω0​t) jπ[δ(ω+ω0)−δ(ω−ω0)]j\\pi[\\delta(\\omega + \\omega_0) - \\delta(\\omega - \\omega_0)]jπ[δ(ω+ω0​)−δ(ω−ω0​)] ejω0te^{j\\omega_0 t}ejω0​t 2πδ(ω−ω0)2\\pi \\delta(\\omega - \\omega_0)2πδ(ω−ω0​) e−atu(t), a&gt;0e^{-a t} u(t),\\ a &gt; 0e−atu(t), a&gt;0 1a+jω\\frac{1}{a + j\\omega}a+jω1​ x(t)=u(t+T/2)−u(t−T/2)x(t) = u(t + T/2) - u(t - T/2)x(t)=u(t+T/2)−u(t−T/2) T⋅Sa(ωT2)T \\cdot \\text{Sa}\\left( \\frac{\\omega T}{2} \\right)T⋅Sa(2ωT​) 互易对称性 双边z变换 等比数列求和公式 离散时间傅里叶变换 初值定理终值定理 连续（s域） x(0+)=lim⁡s→+∞sX(s)x(0^+)=\\lim_{s\\rightarrow+\\infty}sX(s) x(0+)=s→+∞lim​sX(s) x(+∞)=lim⁡s→0sX(s)x(+\\infty)=\\lim_{s\\rightarrow0}sX(s) x(+∞)=s→0lim​sX(s) 离散（z域） x[0]=lim⁡z→+∞X(z)x[0]=\\lim_{z\\rightarrow+\\infty}X(z) x[0]=z→+∞lim​X(z) x[+∞]=lim⁡z→1(z−1)X(z)x[+\\infty]=\\lim_{z\\rightarrow 1}(z-1)X(z) x[+∞]=z→1lim​(z−1)X(z)","link":"/blog/2025/06/07/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"},{"title":"全志H3原理图设计——DDR篇","text":"前言 开发全志H3的核心板过程中，原理图绘制部分有很多新知识，近期博文将全面介绍全志H3的原理图设计，把这些知识整理下来。本篇主要介绍DDR——Double Data Rate SDRAM的电路设计。 配置 CPU: 全志H3 DRAM: DDR3 512MB FBGA-96 CPU-DRAM设计 概述 全志H3的DRAM控制器是32位的，可以支持两片DDR3颗粒，因此所有信号线的低半段代表一片内存颗粒，高半段代表另一颗内存颗粒。 分类 数据线 SDQ[0:31]代表并行数据线，SDQM[0:3]是并行数据掩码，SDQS[0:1]是数据同步信号，为差分信号。 地址线 SA[0:15]代表并行地址线，SBA[0:3]是Bank地址线。 时钟线 SCK是时钟信号，差分信号。时钟差分线正负之间要接一个100Ω的终端电阻。 控制线 SRAS、SCAS分别是行地址和列地址选通信号，SWE为写使能信号，SRST是复位信号，SCKE[0:1]是时钟使能信号，SCS[0:1]是片选信号。 其他 SZQ是阻抗校准线，需要一颗高精度240Ω电阻接地。 SVREF是电压基准，电路如下。 C3靠近CPU的SVREF引脚，C4、C5靠近DDR3芯片。 分组 DDR布线的时候，需要遵循同组同层、同组等长、不同组尽量等长的原则，因此需要对信号线进行分组，方便布线的时候参考。 每个字节对应的所有数据线分一个组 控制信号、时钟信号和地址信号分到同一组 举例：单片DDR3，DQ[0:7]、DQM0、DQS0P、DQS0N分在第一组，DQ[8:15]、DQM1、DQS1P、DQS1N分在第二组。所有的控制线、地址线、时钟线分在一组。 电源 CPU的VCC_DRAM应当与内存颗粒的VCC共用一个电源轨。滤波电容需要有大有小，起码有一个大电容。10uF电容用0603封装。 DDR3颗粒设计 颗粒设计相对简单一些，基本上就是跟CPU的引脚一一对应即可。 DQ数据线的顺序在一个字节内可以随便接！不用管顺序！ 这是因为，虽然数据线是乱序的，但是写入和读取的顺序都是按照这个乱序进行的，乱着写入，乱着读取，两个错误互相抵消，最终的数据不会出错。因此，这个顺序可以根据布线的需要灵活调整。 同一个字节可以随便接，但是不能跨字节，也就是DQ[0:7]必须接到DQL[0:7]范围内，DQ[8:15]必须接到DQU[0:7]范围内 总结 DDR的原理图设计虽然是新知识，但是不算是难知识，照猫画虎即可，比较重复。不过也不能掉以轻心，尤其是ZQ电阻、SCLK终端电阻、SVREF分压电阻的设计，需要严格按照规范，不能想当然。","link":"/blog/2025/03/14/%E5%85%A8%E5%BF%97H3%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94DDR%E7%AF%87/"},{"title":"全志H3原理图设计——HDMI篇","text":"前言 开发全志H3的核心板过程中，原理图绘制部分有很多新知识，近期博文将全面介绍全志H3的原理图设计，把这些知识整理下来。本篇主要介绍HDMI——接口的电路设计。 CPU－HDMI设计 原理图 如图，CPU侧电路主要包括四对差分对、一对I2C，以及HCEC、HHPD。下面将分别介绍 数据线 HTX[0:2]三对差分对是HDMI的数据线。 时钟线 HTXC差分对是HDMI的时钟线 控制线 HSCL、HSDA这一对类似I2C的线路，是HDMI中，预留用来与显示器通信的线路。可以通过I2C总线读取显示器的分辨率等信息。 HCEC是Consumer Electronics Control的简称，他是一个统一的单总线电子设备控制协议，可以通过一根线控制设备进行播放、暂停之类的简单功能。 其他 HHPD是热插拔检测线。 接口电路设计 原理图 从原理图中可以看出，HDMI的数据线和时钟线可以直接与CPU相连，对应的Shield引脚应当接入参考电平（GND）。其他的控制线需要一些外围电路辅助。 HCEC设计 如图，由于HDMI要兼容不同电平的设备，所以HCEC所需要的是一个电平转换电路。D1和R18两个器件组成上拉电路，之所以添加一个二极管，是为了防止另一设备电路的电压高于本设备，通过这根线倒灌到本设备的电源中。Q1和R19组成电平转换电路。工作原理如下： 左发右收：当MOS管左侧为低电平时，HCEC通过MOS管体二极管被下拉到0.5V左右。MOS管左侧为高电平时，HCEC可以正常被R19上拉到VCC。此时，MOS管不导通，因此可以防止左侧电压倒灌到右侧。 左收右发：当HCEC为低电平时，Q1S极电压低于G极电压，因此导通，MOS管左侧被下拉到地。当HCEC为高电平时，Q1关断，此时MOS管左侧被上拉电路拉至高电平。 总之，这个电路可以实现双向单总线的通信，而且可以保证本设备的安全。 HHPD电路设计 HHPD主要实现HDMI插入检测。电路比较简单。 I2C电路设计 I2C电路本质上也是一个电平转换电路。但是由于I2C接口是开漏输出，所以不需要用到MOS管。HDMI中，Source端作为I2C主机，也就是左侧是I2C主机。当主机释放总线时，右侧被上拉到5V。当主机拉低总线时，为了防止5V电源直接灌入，串联一个22Ω电阻，降低电流即可。 理论上不会出现5V电源灌入的情况，应该都会有上拉电阻，但也不排除某些设备设计缺陷，I2C接口用推挽输出。因此最好还是加上。 ESD防护电路设计 HDMI通信速率很高，而且都是差分信号，在选择ESD时，最好要选择集成了多对ESD的芯片，同时也要尽可能的减少ESD管结电容。像我选的TI家的ESD管子，单根线的电容低至0.25pF。ESD电路最好还是加上，因为HDMI热插拔过程中有可能产生静电，不加的话容易打坏元器件。 总结 HDMI接口设计的时候，需要注意控制线和热插拔的外围电路，既要能够做到正常通信和正常功能，还要考虑到不同设备的不同电平、不同设计对本设备有可能产生的危害，并设计电路防护。","link":"/blog/2025/03/17/%E5%85%A8%E5%BF%97H3%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94HDMI%E7%AF%87/"},{"title":"全志H3原理图设计——USB篇","text":"前言 开发全志H3的核心板过程中，原理图绘制部分有很多新知识，近期博文将全面介绍全志H3的原理图设计，把这些知识整理下来。本篇主要介绍USB的电路设计。 HOST部分 USB HOST指的是本设备作为USB主机，对外供电、检测外部连接状态。一般情况下，HOST设备会使用USB Type-A接口连接外部设备。这款掌上电脑设计了两个USB-A接口，作为HOST接口。可以通过HUB转接更多，也可以直接连接键盘鼠标，两个基本就够用了。这两个USB-A接口分别连接到主控的USB2和USB3。 OTG部分 OTG指的是USB On The Go，是USB协议中既能够作为主机（HOST），也可以作为作为设备（DEVICE）的一种设备，在USB Type-C协议规范中被称为DRP——Dual Role Port。 OTG的本质是ID引脚，这个引脚在Micro-USB中存在，但是Type-C中不存在，以CC1/2引脚代替。ID引脚接地代表该设备为主机，ID引脚为悬空（上拉）代表该设备为从机。因此，OTG设备需要不断转换ID引脚电平，直到与设备建立正常通信之后，固定住电平，实现OTG双设备身份。 Type-C就比较麻烦。DFP（主机或Source端）的CC1/2应当上拉，UFP（设备或Sink端）应当下拉。因此，根据规范，需要切换上下拉电阻的连接，不断转换设备身份，直到建立正常连接为止。不过，如果不断改变CC1/2引脚的电平，可以达到一样的效果。因为外部设备一定会有上拉或者下拉电阻，改变电平与改变上下拉状态是一个效果。只不过，如果两个设备都是OTG设备，那么就可能会出现问题。因此，这个电路，只能连接Type-C转A口的线，然后接入其他设备，而且可能只有一面能用。如果是C-C的线，很可能是无法工作的。 实际上，这个接口很可能不会作为HOST端，只会作为DEVICE端。因为这个接口连接了USB转串口的芯片——CH343，只要用到串口，就需要这个接口作为UFP端。不过，为了将所有USB接口都引出，这个口还是设计成了双角色的设备。此外，为了实现串口USB和主控USB的切换，我设计了一个开关可以拨动选择哪一个设备的USB连接到接口。如果连接主控的话，占用主控的USB0。 USB－WiFi 主控还剩余一个USB接口，我把他连接到了USB-WiFi的模块上面，实现WiFi功能。电路如下。 USB转串口——CH343 与CH340的不同主要在于通信速率。根据沁恒官网的内容，CH343最高支持到6Mbps的波特率，CH340只支持到3Mbps的波特率。由于我们的主控非常强大，6Mbps的波特率只能说是小菜一碟，而且调试的时候，串口可能会打印很多东西。因此最好选择一个高速USB串口芯片。 VBUS、VDD5应当连接到一起，接入USB VBUS。V3和VIO可以一起接入3.3V，与板上硬件通信。 总结 USB的设计比较复杂，主要是由于USB-IF组织规定的协议实在太混乱，各种资料、样例五花八门，没有统一的规范。不过，USB仍然是日常使用最经常的接口，尽可能的还是弄清楚各种USB口的电路设计，方便日常使用。","link":"/blog/2025/03/17/%E5%85%A8%E5%BF%97H3%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94USB%E7%AF%87/"},{"title":"全志H3掌上电脑——项目简介","text":"前言 受到稚晖君量子计划的启发，想要自己开发一款类似于稚晖君的“夸克”迷你电脑的板子，用来锻炼自己Linux的开发能力，并提高自己高速PCB的设计能力，熟悉DDR布线。 设计原则 这块板子是我第一次接触DDR布线、第一次画高速PCB，所以并没有选择高性能、新代际的全志H616之类的CPU，而是使用一个老掉牙的H3，主要是想要练手，以及检验一下我的PCB技术能否满足这种高速设计的要求。如果这个板子能够正常工作，那么我就考虑画一个用较新CPU的板子，作为真正Linux开发的平台。 此外，这块板子我打算使用Altium Designer去画，而不是像以前一样一直用嘉立创去画。实话讲，嘉立创EDA完全可以胜任这个工作。只不过我觉得需要跳出一下舒适区，借助这个完全陌生的项目，摆脱一下自己对嘉立创的依赖，学习AD的使用。 配置与接口 大体配置与稚晖君的保持不变，CPU使用全志H3，DDR3单颗内存，512MB，但是保留USB口、HDMI口、网口、电源接口，做到能够独立使用。尽量避免使用邮票孔，多使用BTB接口或者排针进行连接。最好能够像稚晖君一样，打造出一整套系统，用统一的接口定义，转接所有板子。 之所以想使用BTB接口，是因为此前在公司实习的时候，感觉BTB接口非常好用，高速信号没有问题，插入拔出的过程也很顺畅，整体结构也很紧凑。使用BTB接口可以实现可插拔的核心板快速更换，适配各种不同功能。 此外，如果可能的话，最好能够集成一颗EMMC或者Flash。板子上一直插着一块SD卡总是有些不太优雅。甚至可以直接去掉SD卡接口，用EMMC作为存储空间。 网口由于RJ45的接口尺寸太大了，因此打算使用PH2.0排针把网口的四根线引出，然后转接RJ45，这样能省出不少空间。 PCB设计 初步设想使用六层板，一方面是刷新我画的最多层数板子的记录，另一方面是可以用嘉立创免费打样。同样的，由于嘉立创的限制，过孔最小需要是0.3/0.4mm。","link":"/blog/2025/03/13/%E5%85%A8%E5%BF%97H3%E6%8E%8C%E4%B8%8A%E7%94%B5%E8%84%91%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/"},{"title":"基于CarSim的方程式赛车TCS算法开发","text":"FSEC——中国大学生电动方程式大赛是一个全国性的大学生汽车赛事，参赛队伍自主设计、制造一台方程式赛车参加比赛。这里介绍一下我所隶属的车队共同开发的TCS——牵引力控制算法。 仿真平台 CarSim是一款强大的汽车仿真、自动驾驶仿真软件，具有真实的物理引擎，能够模拟各类路面、风等环境与各类发动机、变速箱、差速器乃至电动机、电池构成的车辆。使用它可以轻松的构建出一辆赛车模型，而不需要自己开发复杂的运动学模拟算法。 机械参数设置 车辆的机械参数，来自于FSAE所公开的一辆原型车模型，基本没有做改动。 电气参数设置 电气参数包括三大部分：动力总成、变速器、功率管理。其中动力总成包括电机、电池等。我基于CarSim自带的40kW电机系统开发，修改了一些设置和参数。我没有修改功率管理相关的东西，保持默认了。 动力总成 电池 按照我们车上的实际参数设置的。 2. 电机 按照电机手册设置即可 除了这两块，其他的类似于电池内阻、电池容量等参数我都没有设置，保持默认的。 变速器 按照我们的实际情况，选择了4.4传动比的变速器。 环境设置 默认的道路，摩擦系数约为0.9，这个摩擦力非常强大，即使全油门一脚踩下去，仿真里面的滑移率也不到0.1，所以为了显示出算法的效果，我把道路摩擦系数改成了0.5。 变量接口设置 输入变量叫做IMP_M_MOTOR_CMD，是电动机的输出扭矩指令。输入这个指令就可以改变电动机的输出扭矩 输出变量包括：四个轮子的转速，电机的输出扭矩，右后轮滑移率。其中滑移率数据我没用来做算法，只是验证一下通过轮速计算出来的滑移率是否正确。 控制算法 其实这个控制算法非常简单，各位大佬轻喷。 首先，考虑到程序运行的周期是20ms，整个算法也是以20ms的采样率运行的，但是仿真是以50us的步进运行的。 滑移率计算 该子模块输入前后轮的转速（m/s），计算出滑移率，随后通过一个离散传递函数后输出。该离散传递函数是一个低通滤波器。 记录一下这个低通滤波器是如何设计的。 首先，它必须是α1−(1−α)z−1\\frac{\\alpha}{1-(1-\\alpha) z^{-1}}1−(1−α)z−1α​的形式，也就是αzz−(1−α)\\frac{\\alpha z}{z-(1-\\alpha)}z−(1−α)αz​的形式。在MATLAB里面，对应的是分子[α 0]，分母[1 -(1-α)] α越大，截止频率越高，α越小，截止频率越低。 α=Tsτ+Ts\\alpha = \\frac{T_s}{\\tau+T_s} α=τ+Ts​Ts​​ 其中TsT_sTs​为采样周期。 PID控制 PID输出的是扭矩补偿值，160是车手的踏板输入值，这样就可以补偿踏板给出的扭矩，实现牵引力控制的效果。PID参数如下： 调PID这一步是比较痛苦的。 调试思路 TCS开发过程遇到了不少问题 滑移率起不来 最开始的时候，滑移率一直是很低的数值，代表轮胎抓地力一直很强，这与实车测试结果并不相符。真车跑的时候，一脚油门下去一定打滑，但是仿真没有仿出来。最后只能把道路摩擦系数改为0.5 滑移率滞后 测试过程中，发现电机的扭矩和滑移率并不对应。电机的扭矩上升后，滑移率过了一段时间后才上升，有一个明显的延迟。这导致PID调节很困难。 后来拉出来CarSim计算出来的滑移率，发现并不存在这个问题。 最后定位到问题出在滤波器上。滤波器延迟太大，导致滑移率滞后。 测试结果 可以看到，摩擦系数0.5时，效果还是很好的。","link":"/blog/2025/09/11/%E5%9F%BA%E4%BA%8ECarSim%E7%9A%84%E6%96%B9%E7%A8%8B%E5%BC%8F%E8%B5%9B%E8%BD%A6TCS%E7%AE%97%E6%B3%95%E5%BC%80%E5%8F%91/"},{"title":"基于ESP32-S3的音频开发板设计","text":"前言 按照实验室老师的要求，针对电赛开发一系列开发板，供今年全国电赛的训练和比赛使用。目前主要考虑做音频和信号处理方向的题目。这块板子主要针对音频类题目，基于ESP32-S3，借助ESP32完善的音频生态系统，方便电赛音频题的开发。 本篇博文主要介绍这块开发板的原理图和PCB设计。 原理图设计 ESP32模组 考虑到ESP32模组自带PCB天线、外围电路的优良特性，还是采用模组作为主控，不直接使用芯片。 ESP32模组没什么值得讲的。主要是3V3的电源外部去耦电容和EN（RST）的阻容。按照芯片手册的描述，这两块电路最好完全按照推荐参数设计。 自动下载电路 自动下载电路本质上是一个USB转串口电路。了解这块电路之前，首先要明白ESP32的启动方式和烧录方式。 启动方式 ESP32的启动方式分为两大种，一种叫做Joint Download Boot模式，另一种叫做SPI Boot模式。我们常用的串口下载、USB下载等，都属于Joint Download Boot模式。而如果想让程序正常运行，就需要让ESP32以SPI Boot模式启动。启动模式与GPIO的关系如下： 启动模式 GPIO0 GPIO46 SPI Boot 1 x Joint Download 0 0 由于这两个管脚能够决定MCU的启动状态，他们有一个专门的名字，叫做Strapping管脚。 此外，GPIO0和GPIO46还具有上下拉电阻。它们的默认上下拉电阻如下： 管脚 上下拉 GPIO0 上拉 GPIO3 N/A 由此可见，如果想让ESP32能够下载程序，需要把GPIO0拉低。 ESP32启动之后，这些引脚就与普通的IO口一样，可以被程序使用。 下载方式 首先，EN引脚跟其他MCU的RST引脚类似，如果拉低，则会终止MCU的运行，直到再次拉高之后，MCU重新开始运行。也就是说，MCU会重新检测Strapping管脚的状态，并根据Strapping管脚的组合决定启动方式。 那么，为了让ESP32下载程序，我们需要拉低EN，拉低GPIO0，然后再拉高EN，使得ESP32进入下载模式。总的来说，就是让EN拉高时，GPIO0处于低电平。 ESP32官方开发板上的自动下载电路如图。 Modem联络信号 这一块值得单开一节，非常复杂。先回顾一下串口的一堆Modem联络信号 信号 方向 名称 描述 CTS I Clear to Send 高表示允许本机发送 RTS O Request to Send 本机发送数据前拉高 DCD I Data Carrier Detect 高表示其他设备在线 DTR O Data Terminal Ready 本机可以通信时拉高 DSR I Data Set Ready 高表示其他设备准备好 有点乱，不用怕，还有更乱的。这些信号都是针对电脑和Modem通信而言的，有主从之分，而我们用的是CH340之类的USB转串口，涉及的设备包括电脑、CH340、MCU，那到底哪个是终端，哪个是主机？于是乎，这个表格需要重新做一下。 信号 方向 描述 CTS I 高表示MCU允许芯片发送从电脑接收到的串口数据 RTS O 芯片向MCU发送来自电脑的串口数据前拉高 DCD I 芯片不会考虑终端存在与否，所以没什么用 DTR O 芯片接收到来自电脑的串口数据后拉高 DSR I 高表示MCU准备好发送/接收数据 这还不算完，有的芯片，这些信号是高有效，有些芯片是低有效，比如CH340系列的芯片，这些信号都是低电平有效，也就是说这些描述中的拉高全部要改成拉低，高全部变成低。考虑到所有的因素，最终的表格长这样。 信号 方向 描述 CTS I 低表示MCU允许芯片发送从电脑接收到的串口数据 RTS O 芯片向MCU发送来自电脑的串口数据前拉低 DCD I 芯片不会考虑终端存在与否，所以没什么用 DTR O 芯片接收到来自电脑的串口数据后拉低 DSR I 低表示MCU准备好发送/接收数据 本来以为事情到这里就结束了，结果事实上，CH340压根不考虑以上的这些因素，RTS、DTR只受电脑控制，电脑让他们拉低就拉低，与数据发送无关。所以，这些联络信号的逻辑，还是要看电脑那边怎么控制它。 整了半天，其实只是理清楚这些名词的含义，并没有什么实际的用处。 下载方式续 有了刚才那么多的铺垫，终于可以开始分析电路了。 首先我们把Q13忽略，与我们的分析下载方式无关。 如果DTR为高电平，RTS为低电平，那么Q9将会导通，将EN拉低。 如果RTS为高电平，DTR为低电平，那么Q11将会导通，将IO0拉低。 如果两个都为高电平或都为低电平，那么Q9和Q11都不导通，EN和IO0维持高电平 通过这些电路，电脑可以通过程序控制DTR和RTS的电平，间接控制EN和IO0的电平，实现自动下载的效果。 这个电路的核心效果其实是把一个IO口的电平同步到另外一个IO口的电平，是为了防止DTR和RTS电平过高损坏单片机。对于CH343P之类有独立的IO口供电轨的芯片来说，可以直接把DTR连接到IO0，把RTS连接到EN，也可以实现自动下载的功能 音频编解码器 音频编解码器本质上是一对ADC和DAC，可以把模拟信号转换成PCM编码格式，通过I2S接口输出（编码功能），也可以把I2S传来的PCM数据转换成模拟信号进行输出（解码功能）。我们这块板子使用的是一个ES8311芯片。 ES8311的外围电路完全照抄芯片手册即可，不需要什么特别的设计。需要注意的是，ES8311需要I2S输出MCLK信号，算上DO、DI总共是五根线，可以说把I2S用到极致了。 音频功放 音频功放的作用是把DAC输出的音频信号进行电流放大，使其能够驱动更加大功率的喇叭，发出更大的声音。关于功放的内容足够单开一篇文章去写了。这个设计使用的是NS4160 D类音频功放，它的特点是功放效率比较高，适合与我们这种体积比较小的板子 其他 电源 使用SY8089芯片产生3.3V电源，它的持续输出电流可以达到2A，配合一个大小合适的2.2uH电感（我用的4030的电感，其实252012应该也够）。值得一提的是，我在电源的EN引脚上增加上拉电阻和按键，可以通过按下按键断掉3.3V电源。有个缺憾是忘了在按键两端并联一个100nF电容起到消抖的作用。 LED 增加三个LED，分别是5V、3.3V和用户LED。 PCB设计 PCB设计没有太多值得关注的。首先这是一个开发板，需要引出尽可能多的引脚用来开发，这就要求ESP32上需要走出很多线，连接到开发板两侧的排针。在连线的时候，建议从排针出发，按照顺序拉出整齐的排线，然后根据排线的顺序，在顶层把ESP32的引脚连出一定长度，越过形成阻挡的线，打上一个过孔，这样每一根线都只需要一个过孔就可以联通，而且排线看起来比较整齐，走线的顺序通过换层实现了重排。 走完所有信号线之后，空间已经很有限了，所以中途改成了四层板，第二层做地层，第三层做电源层。电源层走了两个网络，一个是3.3V，一个是5V。 2025.4.24更新 调试 这块板子的调试没有遇到很多的问题，不值得单开一篇讲了。 自动下载电路正常，程序下载很顺利。 ES8311与ESP32的通信没有问题，正常输出音频信号，但是忘了引出DAC直接输出额接口，没接功放的情况下没法听效果。 由于使用了CH343P高速USB转串口芯片，我想测试一下超高速的串口能不能实现。由于CH343只接到了UART0，所以只能通过系统debug信息测试。修改debug端口波特率到6Mbps，结果并不理想，烧录失败、输出乱码。修改到3Mbps，烧录和串口输出均正常。 WiFi连接顺利。","link":"/blog/2025/04/12/%E5%9F%BA%E4%BA%8EESP32-S3%E7%9A%84%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AE%BE%E8%AE%A1/"},{"title":"基于VSCode的ESP-IDF编译环境搭建","text":"前言 项目要求，需要搭建一个ESP32的开发环境。目前，主流的开发方式都是使用VSCode搭配ESP-IDF插件，但是我在本地搭建环境时，遇到了各种问题，在本文记录下来，作为以后开发的参考。 自以为是的搭建方法 按照此前VSCode的开发习惯，在VSCode中安装好插件之后，应该就已经能够进行开发了。ESP-IDF的VSCode插件安装好后，会自动提示进行初始化的Config，按理来说，根据提示一步步操作之后，就能够自动下载好ESP-IDF的库和编译工具链，以及所需要的Python虚拟环境等。我按照这个提示操作完成之后，几个项目都无法编译，提示五花八门，有时候提示缺少python的库，有时候提示语法错误，总之就是不能编译 正确的搭建方法 参考https://blog.csdn.net/shengzhe8688/article/details/132331713的搭建方法。 删除所有的ESP-IDF路径和文件。 去官网下载离线安装包，这里由于网站网址更改了，不能用CSDN博文的网址，应该使用https://dl.espressif.com/dl/esp-idf/。 使用离线安装包安装ESP-IDF 在VSCode中新建一个配置文件（我这才第一次知道有这个东西，还挺好用），也就是新开一个环境，不会有之前安装的扩展。 安装ESP-IDF扩展 在ESP-IDF配置的时候，选择Using Existing Setup。 选择刚才ESP-IDF安装路径 等着就行了 这样安装好之后可以正常编译了。","link":"/blog/2025/02/25/%E5%9F%BA%E4%BA%8EVSCode%E7%9A%84ESP-IDF%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"大创——多传感器融合的供水管网监测系统——项目简介","text":"前言 本文将对即将开展的大学生创新创业训练项目——多传感器融合的供水管网监测系统——进行介绍。后续博客将持续更新项目开发进展和遇到的问题。 项目简介 背景 目标 使用多种传感器，实现对设备安装处的供水管网进行流量监测、温湿度监测、漏水监测等功能。 基础 实验室此前的研究中，研究过基于声学定位的漏水监测算法，可以实现音频信号对漏水情况的监测。在软件开发方面，对STM32L系列低功耗单片机有一定的开发经验。此外，对433MHz或LoRA协议等无线通信协议也有一定的研究，为本项目的开展奠定了基础。 技术路线 传感器 流量传感器 机械流量传感器 与传统的水表工作原理相同，需要对管网进行改造，不适用于本项目。 超声波流量传感器 超声波在流体中的传播速度等于流体的流速与声波的速度的和，基于这个原理，开发出的超声波流量传感器。只需要在管道两侧分别安装两个换能器，即可实现监测功能。 磁性流量传感器 类似于粒子发电机，借助磁场对正负粒子的偏转作用，对管道中的流量进行监测。 温度传感器 选择很多，比如DS18B20等。 湿度传感器 湿度传感器需要能够在土壤里面工作，需要能够监测出漏水导致的湿度上升等变化。 To be continue… 主控芯片 云服务器 控制算法 难点解剖 低功耗运行 远程无线通信 多传感器融合算法","link":"/blog/2025/03/10/%E5%A4%A7%E5%88%9B%E2%80%94%E2%80%94%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E7%9A%84%E4%BE%9B%E6%B0%B4%E7%AE%A1%E7%BD%91%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B/"},{"title":"微机原理课程笔记","text":"记录一下微机原理的重点和学习体会。 CPU原理 BIU：总线控制单元 EU：指令执行单元 寄存器 AX,BX,CX,DX是与数据有关的，SP,BP,SI,DI是与地址相关的，SS,DS,ES,CS是与段有关的。 为什么BX也是和数据相关的呢？因为BX中存储的内容可以是数据，也可以是指针。这时候指针就可以被认为是数据的一部分。即，我的数据是一段地址而已。 所有X寄存器（AX,BX,CX,DX）都可以被拆成高低两个小寄存器。例如AX可以拆分出AH和AL。 FLAGS中的9个标志位 CF只和溢出位有关。只要溢出就是1 AF只和第四位有关。第四位溢出就为1 SF只和最高位有关。最高位为1就为1 PF只和1的数量有关。偶数个1就为1 ZF只和0的数量有关。全是0就为1。 以上说的，都是根据二进制运算结果的状态判断的。 唯一一个例外是OF。OF是操作数和结果状态共同决定的。11-&gt;0和00-&gt;1会产生OF。 寄存器是属于EU的 三个地址 物理地址=段地址×16+偏移地址 指令：CS:IP 堆栈：SS:SP 存储器 20位地址，1MB寻址空间（220=1024768=1024×10242^{20}=1024768=1024×1024220=1024768=1024×1024）。 AD19-0 读写周期 首先明确几个标志位。 BHE选择奇地址 ALE使能地址锁存器 DT/R给出数据锁存器方向 M/IO选择目标设备 RD/WR使能目标设备 DEN使能数据输出 所有读写周期的各种时序，都是由BIU控制的。 指令系统 寻址方式 比较重要的是：直接寻址，寄存器间接寻址，寄存器间接相对寻址，隐含寻址。实际编程中很少用到变址寻址。 指令 需要记住的： MOV A,B。这个记不住就不用学了 MOVX A,B。 JMP A。包括：JMP,JC/JNC,JZ/JNZ。十分重要！ LOOP A。每次LOOP CX－1 IN A,B OUT A,B 8255接口 8255是一个IO扩展芯片。 8255有四个寄存器，A口,B口,C口,控制口。对应00，01，10，11四个地址。这四个地址在8255上，表示为A1和A0。8255还有一个CS片选端。这样组成了一个相对复杂的系统。 D0~D7的数据，可以被送到四个地方，也可以从四个地方读取。送到哪里取决于地址线设定哪里。要想使用控制字，必须将数据送到控制口，这样数据才能作为控制字。要想读取A口状态，地址线必须设置到A口。 控制字决定的是工作模式，实际的IO高低电平状态、选通输入状态等，不是控制字给的。 8255的控制字如下。 图中展示的，最高位必须是1，即方式选择控制字。最高位为0的时候是另外一套控制字。 方式0：基本输入输出方式 方式1：选通输入输出方式 方式2：双向传输方式 以这个系统为例。8255的A1,A0接到了8086的A2,A1。假设我想把数据送到控制口。即8255的A1A0需要为11。那么，8086的A2A1需要为11。8255的CS接入了74LS138的Y4，为了使Y4拉低，使能8255，需要先把G1G2G3置为100，即A7,M/IO,A6,A5分别为1011。Y4对应到CBA分别为100，即A4,A3,A0分别为100。 总结： A7~A0分别为11110110，即F6H。M/IO为0，即处于读写IO状态。 同理，A口地址为F0H，B口地址为F2H，C口地址为F4H。因为M/IO必须是0，即读写IO状态，那么必须用IN或者OUT指令，不能用MOVX。 要想实现题目中的功能，只需要读取A口状态，将A口状态原封不动写入B口即可。控制字应当把A口和B口都设为方式0：基本输入输出方式。 转换成代码，就是： 12345678MOV DX,0F6H #控制口地址MOV AL,90HOUT DX,AL #控制口写入90H，A口方式0，输入，B口方式0，输出MOV DX,0F0H #A口地址IN DX,AL #读取A口数据MOV DX 0F2H #B口地址OUT DX,AL #数据输出给B口 DAC和ADC","link":"/blog/2025/10/27/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"title":"第一篇博文，记录hexo+Github Pages搭建个人博客的过程","text":"摘要 由于手中项目逐渐增多，不断地发现自己经常遗忘之前项目的很多细节。我由此想搭建自己的个人博客，用博客来记录自己各个项目的开发过程、遇到的问题和解决方案，作为自己的长期记忆，存放在电脑里，还可以作为自己的展示平台，把自己的能力通过实打实的项目展现出来。我整合了整合了十几篇教程的方案，结合一些新技术和思路，实现了方便、快捷的博文撰写，美观实用的博客浏览。本文将详细阐述整个搭建过程和注意事项。 前言 由于手中项目逐渐增多，不断地发现自己经常遗忘之前项目的很多细节。比如，代码无法编译后怎么解决、硬件短路后怎么排查、项目开发的注意事项等等。在朋友的建议下，我发现搭建自己的个人博客，用博客来记录自己各个项目的开发过程、遇到的问题和解决方案，作为自己的长期记忆，存放在电脑里，是一个不错的办法。很多大牛也都用自己的博客记录自己项目开发经历，这种方式不仅能帮助自己回忆此前的项目细节，还可以作为自己的展示平台，把自己的能力通过实打实的项目展现出来，同时，这些博文对刚入门的小白也会有很强的指导作用。之前我就访问过稚晖君的个人博客，感觉受益匪浅，涨了很多见识。 综上，我也开始搭建自己的个人博客。实话讲，个人博客的搭建，网络上的教程多如牛毛，基本上跟着做就不会有什么问题。但是，我自己的方案是整合了十几篇教程，结合一些新技术和思路，实现了方便、快捷的博文撰写，美观实用的博客浏览。 废话到这里就结束了。下面开始正文。 本篇博文将详细地介绍自己搭建个人博客的全过程。我的博客基本框架是使用hexo，这是一个非常常用的个人博客框架，可以设置多种主题，实现许多定制功能，并且部署也比较简单。服务器直接使用Github Pages，免费，而且不需要备案，但是国内访问可能会出现缓慢、卡顿等问题，每个人的访问情况也都不太相同，不如使用阿里云等云服务器搭建来的稳定。 构思 hexo搭建博客有很多好处，但基本上都是针对访问者而言的。比如，他的界面简洁漂亮，归档分类都很好找，浏览体验也很好之类的。但是，hexo的一大缺点就是写作过程不算是很优雅。原因主要在于，hexo需要在命令行执行新建博客操作，然后在Markdown编辑器里面写好文章之后，回到hexo命令行，执行hexo g &amp;&amp; hexo d指令，以部署静态页面到Github Pages网页上去。这个过程不够优雅，命令行的操作显得非常原始，既不好几页不好用。为了解决这个问题，同时也借鉴了网络上的解决方案，基本思路就是把源码（博客文档）提交到Github上去，让Github自己执行部署程序，这样就省去了自己去hexo命令行输入指令的过程，可以便捷的撰写和修改。写完的博客直接同步的Github上去，网页端就会自动出现新写的博文了。 有了这个思路，那么具体的技术架构该怎么搭建呢？本地的hexo只用于初始化源码的生成，后续的博客撰写工作不需要使用hexo命令，可以直接在文件夹里新建一个markdown格式的文件就可以。Github上新建一个库，master分支用来保存hexo的源码，这一部分与本地是保持同步的，新建一个gh-pages分支用于储存静态页面文件，使用Github Action把master分支的内容编译、生成静态页面，更新到gh-pages分支，然后Github Pages会自动运行一个action把gh-pages的文件部署到服务器，即可被公网访问打开。 搭建步骤 准备工作 首先，电脑上需要安装Git。后续的本地云端源码的同步工作都依赖于这个环境。其次，电脑上需要安装node.js，是hexo的前置环境。安装时要勾选添加到PATH，安装完成之后重启电脑。 安装hexo 打开一个命令行，先输入 1node -v 确认node安装无误之后，输入 1npm install hexo -g 这样，就安装好了hexo 初始化源码 在想要存储hexo源码的地方打开一个命令行，输入 1hexo init 本地预览 同一个命令行，输入 12hexo g #生成静态页面hexo s #启动服务器 根据提示，在浏览器中输入http://localhost:4000，即可访问本地网站。 部署设置 还是那个命令行，输入 1npm install hexo-deployer-git --save 打开博客目录下的_config.yml，拉到最后，填写deploy模块 这一串填写的意思是，hexo部署的时候，会以git部署到指定的repository里面的指定branch。使用这种方法部署的前提是本机git具有该repository的访问权限，需要提前设置RSA密钥之类的东西。 设置完这一部分之后，如果输入hexo d命令，就会把静态页面部署到github上。 Github设置 按图设置。核心是选择Source为Deploy from a branch（默认就是这个选项），然后选择gh-pages作为静态页面的branch。 一切正常的话，设置好这一部分之后，在hexo命令行中输入hexo d，Github接收到push请求后，就会自动开启一个名为&quot;pages-build-deployment&quot;的action。 自动部署 如前文所述，自动部署的核心是上传hexo源码，然后让github自动执行一个action，把源码编译成静态页面，并推送给gh-pages。那么，我们只要写出一个action，完成上面的工作，就可以了。 以下是action的代码 1234567891011121314151617181920212223242526272829303132333435363738name: Build and Deployon: workflow_dispatch: push: branches: - masterjobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [22.x] steps: - uses: actions/checkout@v4 - name: Install npm run: | npm install npm install hexo-asset-img --save - name: Prepare Github Identity env: HEXO_DEPLOY_PRI: ${{secrets.SSH_PRI}} run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name zhuwenguan git config --global user.email 170981799@qq.com - name: Deploy Blog run: | npm run build npm run deploy 至此，hexo+Github Pages部署个人博客的步骤就结束了。 杂记 添加分类和标签 在hexo中输入hexo new page categories，即可新建一个名为categories的文件夹。里面的文件打开之后，添加“type: “categories””。如下。 post和page用不同的布局 hexo的模板是有顺序的，最高级是_config.post或_config.page，其次是config.，最后是_config.yml。所以只要新建_config.post和_config.page，分别设置post和page的页面布局即可。 附：自己的_config.post设置 12345678910widgets: - type: categories position: left - type: recent_posts position: left - type: toc position: right VSCode自动插入带相对路径的图片 由于hexo启用了post_asset_folder，也就是每篇博文新建一个同名文件夹用来存储素材，比如图片之类的，但是这样的话，VScode编写过程中，直接Ctrl+V粘贴的图片不会放到这个文件夹里，而是放到与md文件同一目录下。增加一条设置就可以解决这个问题","link":"/blog/2025/02/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"},{"title":"FSEC2025控制答辩","text":"FSEC2025控制部分答辩准备 往年情况 控制领域一直是NRT车队的一大弱项。往年NRT车队的控制策略长期停留在：驱动系统激活、待驶状态管理、加速踏板指令等能让车跑起来的最基本功能。由此带来的问题是： 车辆动态性能没有完全发挥 由于缺乏完善的扭矩控制、牵引力控制算法，车辆动态性能下限低，上限过于依赖车手操控。 车手对赛车状态没有客观的感知 车手无法实时了解如当前扭矩、系统温度、故障标志、能量状态等信息，只能依靠体感判断车辆状态。影响驾驶表现。 车辆调试过程中，缺乏必要的信息显示 调试阶段缺乏实时数据监控、信号可视化等信息显示，导致调试过程中无法快速排查问题，效率极低。 VCU对整车控制能力弱 原本可以由VCU控制的信号，由于无法修改程序，只能由硬件电路控制，增加了整车电气系统复杂度。 追根溯源 为了进一步分析控制系统长期薄弱的根本原因，我们从团队管理、技术能力和硬件基础三个维度进行了梳理，总结如下： 车队管理问题 VCU开发在车队成员换届过程中断档。新成员没有得到培训，无法开发VCU程序 算法开发经验缺失 车队成员缺乏算法开发的经验，无法应用Simulink实现所需的功能。 信息采集量少 赛车安装的传感器数量少，且数据没有被有效保存和使用 信息显示量少 屏幕只显示极少的数据，车手无法获取足量的信息 技术路线 为了解决车队在控制领域存在的问题，我们在今年的研发之始，就制定了控制策略开发的技术路线。 分为短期目标和长期目标。 短期目标：找回VCU开发流程 从0开始，研究VCU开发流程 重写VCU程序，验证VCU开发流程的有效性。 在上述流程顺利的情况下： 重做仪表，设计全新的UI，显示更多信息 重新标定油门踏板 重新标定电机扭矩，以适应整车动态性能 长期目标：实现高级控制策略和算法 分为三条支线： 仿真开发算法 建立并验证CarSim车辆模型 基于CarSim和Simulink联合仿真，开发牵引力控制算法 开发针对不同动态项目的策略 完善车辆传感器 开发轮速传感器 开发加速度传感器 开发悬架行程传感器 开发转向角传感器 实现车辆数据采集 实现CAN总线报文采集 实现传感器数据采集（独立于整车） 开发成果 1.VCU程序开发 今年，NRT车队从0开始，将VCU程序从编写、转译、编译、下载的全流程研究明白。 梳理了之前VCU程序的信号流，将原来的程序进行了大量优化，既提高了性能，也方便了开发和管理。 原来的程序 新开发的程序 2.全新的仪表 将整个屏幕全部替换掉，重新做了一套仪表，增加了很多显示的内容。 3.CarSim与Simulink联合仿真 我们基于FSAE公开的一辆赛车模型，根据我们赛车的实际情况进行修改，建立了一个CarSim模型，用于控制算法的验证。 必须承认的是，我们的Carsim模型与实际车辆仍然存在较大差异。尤其是在轮胎参数的选择上。在μ\\muμ为0.9时，即使油门输出瞬时达到最大，车辆仍然没有明显的打滑情况。这点与实车情况差距较大。不过当μ\\muμ为0.5时，车辆的状态与实车较为类似，在起步时有较大的打滑。 4.TCS算法仿真开发 基于Carsim和Simulink，在仿真中，开发了一套TCS算法。 使用前轮速和后轮速计算滑移率，根据实际滑移率与目标滑移率之差，应用PID算法，实现扭矩补偿。 滑移率计算公式如下： rslip=v−max(ωr,0,01)max(ωr，0.01)r_{slip}=\\frac{v-max(\\omega r,0,01)}{max(\\omega r，0.01)} rslip​=max(ωr，0.01)v−max(ωr,0,01)​ 在我们的算法中，vvv也就是车辆速度是使用的前轮轮速传感器，ω\\omegaω也就是后轮轮速，来自于电机控制器所测量的后轮转速。0.01的作用是，在车辆静止的情况下，ωr\\omega rωr为0，求出的滑移率为无穷大，显然不符合实际情况。 设定目标滑移率为0.2，对滑移率误差应用PID，即可得到补偿扭矩。 考虑到安全性和车手对车辆的操控性，我们限制了TCS算法输出的扭矩不得超过车手输入扭矩的±20%，并且在仪表上添加了TCS开关，保证车手对车辆始终拥有最高操纵权，避免人机对抗的情况发生。 TCS算法截图 实际应用中，存在很多滑移率不可能到达0.2的情况，例如车辆静止时，滑移率始终上不去。这时候如果PID控制器，尤其是积分器始终运行的话，会导致积分器的结果极大，影响控制效果和响应时间。因此必须对积分器实行合适的抗饱和策略。我所使用的Anti Wind-Up策略是Clamp，就是在输出饱和时停止积分器输出。 TCS算法效果 5.轮速传感器 TCS系统如果想要上车，必须有轮速作为原始数据。因此今年传感器开发的首要目标就是轮速传感器。我们用霍尔传感器，在轮边上安装带有凸齿的不锈钢圆环，让传感器感应磁场信号，产生频率可变的矩形波形。VCU采集矩形波的频率，就可以计算出轮胎的转速。 ![[答辩准备/mmexport1763302791795.jpg]] 假设采集到的PWM信号周期为TTT 角速度ω=NT角速度\\omega=\\frac{N}{T} 角速度ω=TN​ 其中NNN为金属环的齿数。 6.数据采集盒 为了实现基本的数据采集，我们自主开发PCB和程序，做了一套完全符合我们需求的数据采集盒。 采集到的数据保存到SD卡里面，后续在电脑上进行处理，可以生成一个类似于这样的表格。 利用这些数据，我们还做了一些很酷的事情 油门开度的曲线，和车载视角结合在一起，生成了一条视频，可以帮助车手训练，也可以帮助调整车辆设定，也可以作为算法优化的参考。 对于任何一支成熟的电动方程式车队而言，最理想的数据获取方式无疑是实时遥测。但是这个数据采集盒，是在设备、经费有限的情况下，采集实车数据的一次大胆尝试。这一次创新，让我们首次能够采集车辆跑动的实时数据，让我们车队脱离了“盲调”，实现了基于数据的车辆调试，把NRT电车的科技化、数字化程度提高到了新的层级。","link":"/blog/2025/11/17/%E7%AD%94%E8%BE%A9%E5%87%86%E5%A4%87/"},{"title":"蓝桥杯单片机编程技巧","text":"前言 最近准备给班里同学介绍一下蓝桥杯单片机的比赛经验，把我去年自己研究的单片机比赛常用的编程技巧分享给大家，提升编程效率和效果。本篇文章同步介绍有关内容，顺带作为教案，方便PPT制作。 概述 蓝桥杯使用的单片机芯片型号是IAP15F2K61S2，属于STC15F系列，是STC15F系列的最高级别芯片。他还有一个姊妹芯片叫做STC15F2K60S2。两颗芯片几乎一模一样，最大的区别是前者支持单芯片在线仿真调试，后者不支持。所以，编程的时候，如果找不到IAP15F2K61S2的相关资料，可以直接用STC15F2K60S2的，他们的外设、内核都一样，代码是互通的。 蓝桥杯单片机主要考察的点有：IO口操作、I2C总线、One-Wire总线、计数器/定时器、芯片自定义总线、UART串口等。下表详细介绍这些知识点所对应的功能： 知识点 外围芯片 功能 IO口操作 \\ 按键扫描 IO口操作 译码器、锁存器 数码管显示 IO口操作 译码器、锁存器 LED IO口操作 译码器、锁存器 蜂鸣器 IO口操作 译码器、锁存器 继电器 I2C总线 PCF8591 电位器输入 I2C总线 PCF8591 光敏电阻 I2C总线 PCF8591 DAC输出 I2C总线 AT24C02 EEPROM One-Wire DS18B20 温度检测 计数器 NE555 频率检测 定时器 CX20106 超声波测距 特殊总线 DS1302 实时时钟(RTC) UART总线 \\ 上位机通信 近年的蓝桥杯题目，基本上会同时考察上面所有内容。而且不同的功能之间会有联系，比如，数码管实时显示NE555的频率，频率大于10kHz后，让某个LED亮起。有些题目会掺杂一些情景描述，比如去年国赛融入了一个无人探测车的背景，需要一些坐标的计算。 我只想讲几个比较困难的，频率检测、温度检测、超声波测距，以及自己的心得体会。其他的比如数码管、LED之类的，自己去网上搜索或者B站看课就行，我就不讲了。 基础代码框架 蓝桥杯的代码写起来还是比较困难的，主要是因为任务比较多，而51单片机的计算速度又慢得很，所以每个任务都会占用不少时间。时间与算力是直接相关的。如果一个任务计算完成需要很多时间，那么就代表他的计算需要很多的算力。所以优化代码主要就是优化时间。 这么多任务，代码怎么样安排呢？很多网上的模板都是这样写的： 12345678910111213void main(){ 初始化1(); 初始化2(); ... while(1) { 任务1(); 任务2(); ... Delay1ms(); }} 我不建议使用while(1)作为程序的主循环。首先，任务执行的时间并不是固定的，有可能第一次执行这个任务的时候，所用时间比较短，第二次执行的时候用的时间比较长。那么就会导致第一次循环和第二次循环总时间不一样。这就容易导致数码管亮度不均匀之类的问题。其次，这样写，没有办法控制整个代码的运行速度。如果里面的任务执行速度很快，那么循环就很快，但是我们压根不需要这么快的速度；如果里面的任务执行很慢，就会发现整个系统都被拖慢了，我们无法定位具体是哪个任务拖慢的速度，也无法主动的干预。第三，由于这样写无法确定程序执行的时间，很难做出软件PWM或者LED定时闪烁之类的功能。 去年我参赛的时候，练习的所有代码都是用定时器中断作为主循环的。定时器中断是定时器溢出的标志，通过设置定时器的初值和自动重装载值，可以改变它溢出的时间。STC-ISP里面有专门的定时器计算工具，可以让定时器以任意时间间隔溢出，产生中断。比如，我常用的是用1ms的定时器中断。每次产生中断时，开始执行代码。比如这样： 12345678910111213void main(){ 初始化(); while(1);}void Timer0_Interrupt() interrupt 1{ SegCalc(); //计算数码管显示值 SegRefresh(); //刷新数码管 KeyScan(); //按键扫描 任务1(); 任务2();} 而main函数里面只执行初始化代码。执行完之后直接while(1);无限等待。 这样写的好处就是，每一次进入中断的时候，都是上一次进入中断的1ms之后，时间非常准确。那么，数码管刷新、按键扫描等基本功能的刷新率都是稳稳的1kHz，不会因为其他代码执行导致刷新率变化，也就不会有闪烁、亮度不均等问题。 这样写也有一个问题，就是在中断当中执行的代码，时间不能太长。因为中断是1ms进入一次，如果中断代码执行时间大于1ms，那么上一次中断还没执行完，下一次中断又来了，整个程序就会被卡住，无限进入中断，永远执行不完代码。这就是我们认为的“跑飞了”。 所以这么写，一定要保证执行的时间不要大于1ms。那如果执行时间大于1ms咋办？最简单的办法就是，把定时器中断时间从1ms改成2ms，这样代码执行时间只要小于2ms就行了。不过这个数不是随便加的，51单片机定时器中断的时间理论最大值是 tmax=65536×1212×106=0.065536s=65.536mst_{max}=65536×\\frac{12}{12×10^6}=0.065536s=65.536ms tmax​=65536×12×10612​=0.065536s=65.536ms 这是在定时器设置为12T的情况下。 65ms的刷新速度其实是有点慢的，一般10ms我觉得是算是可以接受的最大时间了。这个时间很充裕的，如果你的代码无法在10ms内执行完的话，就该考虑一下优化代码了。 有同学会问了，如果我的代码不是1ms执行一次，而是1s执行一次，比如让LED闪烁。那这个定时器中断每次都是1ms，怎么办？ 1234567891011//1ms @ 12.000MHzvoid Timer0_Interrupt() interrupt 1{ static unsigned int cnt; cnt++; if(cnt &gt;= 1000) { cnt = 0; 任务(); }} 这样写，任务就是1s执行一次了。这样写你会发现，1s内的大部分时间，代码只执行了cnt++，没有干别的，只有cnt到了1000的那一次，才会执行任务。这种代码我们成为非阻塞式代码，没有到它执行的时候，就跳过，不在它身上浪费时间，只有它需要执行的时候，才会执行。非阻塞式还包含执行的过程是否阻塞，这里不讨论了。 温度检测 难点 之所以把温度检测放在定时器中断后面，就是因为，温度检测对定时器中断来说是个灾难。温度检测所用的DS18B20芯片是单总线芯片，单总线的特点就是慢。比如，它的初始化需要拉低460us，如果我们用1ms的定时器中断的话，一个初始化一半时间没了，这还没开始读取呢。后面读取的速度也是慢的离谱。如果把温度检测的任务加入定时器中断，那么100%会跑飞。 解决方法 首先，直接读取是不可能的了。其次，如果像刚才那样，加上一个cnt，一段时间执行一次，可以不可以呢？可以，但是不好。那样的话，视觉上会发现数码管有固定时间的卡顿，一会卡一下一会卡一下，整体流畅度还是不好，而且刷新率慢。我的做法是，分步执行。 具体来说，DS18B20读取分8步，初始化，发送跳过ROM校验指令，发送开始转换指令，重新初始化，发送跳过ROM校验指令，发送读取数据指令，读取数据1，读取数据2。每一步都有严格的时间限制，但是两步之间的间隔没有严格的限制。因此，我把它分步执行，每一次定时器中断只执行其中一步，由于定时器中断会不断进入，最终还是可以把所有步骤走完。这样每一个定时器中断都不会因为读取温度占用太长时间，就可以避免温度读取导致整体混乱。 示例代码 1234567891011121314151617181920212223242526float DS18B20_ReadTemp(){ float temp1; unsigned char byte1, byte2; static unsigned char step; switch(step) { case 0: DS18B20_Init();break; case 1: SendByte(DS18B20_CODE_SKIP_ROM);break; case 2: SendByte(DS18B20_CODE_START);break; case 3: DS18B20_Init();break; case 4: SendByte(DS18B20_CODE_SKIP_ROM);break; case 5: SendByte(DS18B20_CODE_READ);break; case 6: byte1 = ReadByte();break; case 7: byte2 = ReadByte();break; } step++;} 这里面的每一步自己再实现就可以了。蓝桥杯的数据包里面有相应的代码。 译码器、锁存器操作 译码器和锁存器搭配起来，可以把P0口复用，同一个P0口控制四个不同的功能，分别是LED，数码管位选，数码管段选，达林顿管阵列（蜂鸣器、继电器、步进电机等）。用P25、P26、P27三个IO口控制3-8译码器，进而控制锁存器的锁存状态，使得P0口的数据发送到不同地方。 下面这个表格介绍了三个口不同电平对应的功能 P27 P26 P25 Y P0口功能 1 0 0 4 LED 1 0 1 5 达林顿阵列 1 1 0 6 数码管位选 1 1 1 7 数码管段选 Y代表使能的锁存器序号。 这块是基础，但是容易出问题。我当时练习的时候，经常能够碰见LED干扰数码管、数码管干扰达林顿等情况。比如，LED0需要亮起，但是数码管并不需要亮，结果每个数码管的同一段都有点微微亮。或者LED不需要亮，数码管需要，但是LED会微微亮。或者数码管最后一位显示的内容会重影在第一位数码管上…这些都是译码器没有写好导致的。 比如说，如果现在P2的三个口从高到低分别是111，即处于数码管段选状态。接下来，我想要改成控制LED，即改成100。那么我可能写出以下代码： 12P25 = 0;P26 = 0; 如果这样写就出问题了。因为第一句执行完之后，P2的三个口变成了110，也就是控制数码管位选。换句话说，我本来想要控制LED的，但是在改变P2口过程中，顺带改变了数码管位选。那么就会导致不属于这一位数码管的数据显示到上面去。但是由于马上就会把P25置1，所以数码管位选只被控制一瞬间，后面可能会被正确的数据覆盖掉，因此只会人眼看起来是一个不太亮的虚影。 为了解决这个问题，我建议每次更改3-8译码器状态，也就是更改P2的三个口状态的时候，都遵照以下的顺序： 12345678910void LatchControl(unsigned char latchNum,unsigned char latchCode){ P0 = latchCode; //改变P0的值 P25 = latchNum &amp; 0x01; //先赋给P25 P26 = latchNum &gt;&gt; 1 &amp; 0x01; //然后赋给P26 P27 = latchNum &gt;&gt; 2; //最后给P27 P27 = 0; //马上清零，失能所有锁存器 P26 = 0; P25 = 0;} 这样写是因为，我们只用到了4567四个锁存器，也就是说，不管控制哪个锁存器，P27都是1。那么只要P27不是1，四个锁存器都不会被控制。因此，P27 = 0;就可以失能所有锁存器，也就不会互相干扰了。所以控制的时候，先改变P25、P26的值，最后让P27为1，而清零的时候，先清零P27，然后再清零P25、P26，这样就能避开所有干扰。 频率检测 原理 NE555是一个方波发生器，根据不同的外围电路，可以产生不同频率、不同占空比的方波。蓝桥杯的这块板子上面，NE555会产生可变频率的方波，频率由板子上的旋钮决定。旋钮就是电位器，通过改变电阻的大小改变方波的频率。方波频率的范围大概是几十赫兹到35000Hz左右。 硬件上，NE555的输出可以通过一个跳线帽连接到单片机P34口，P34可以设置成Timer0的脉冲捕获输入。利用Timer0的脉冲捕获，可以对P34口的脉冲进行计数，进而求得频率的大小。 频率的含义，是一秒时间内信号的周期数，因此，求频率有两种方案，一种是定数计时，比如测量信号100个周期用了多少时间，然后计算得到频率。另一种是定时计数，比如定时1s，测量信号跳变了多少个周期，得到频率。 对于单片机来说，定时计数方案比定数计时方案要简单很多，但是效果比较差，刷新率不高。定数计时方案效果非常好，刷新率飞快，比官方的示例程序效果还好，两种方案都可以学习一下。 定时计数方案 定时计数的基本原理，就是数出一段时间内，信号经过了多少个周期。假设我们数200ms，这200ms内数了130个周期，那么一秒钟的时间，就应该会有130×1000ms200ms130×\\frac{1000 ms}{200 ms}130×200ms1000ms​个周期。这样就检测出来了信号的频率。 如果数200ms，那么显然结果的刷新率就是5Hz，因为1s时间最多数5轮。所以，数据的刷新速度是很慢的。这样数还会带来另一个问题，根据刚才的公式，得到的频率是130×5130×5130×5，也就是Counts×5Counts×5Counts×5，而CountsCountsCounts肯定是整数，所以得到的结果，肯定是5的倍数。反映在效果上，就是得到的频率，全都是5的倍数，没有1234、6789，测量的精度很低，这个效果显然很差。 想要解决这个问题，也简单，数1s时间内的周期数，就可以了。因为1s时间的周期数直接就是频率，不用乘一个系数，所以精度能够保证是1Hz。但是这样的话，刷新率比刚才200ms更低了，数1s时间，也就是说1s才刷新一次数据，刷新率很低。 虽然刷新率很低哈，但是蓝桥杯的评委不看刷新率，所以这样也是可以的，分数能拿到。效果只是满分的基础上精益求精的东西。 精度=1s采样周期精度=\\frac{1s}{采样周期} 精度=采样周期1s​ 随便写了点实例代码，大概看看思路就可以。 12345678910111213141516171819202122232425262728293031//Timer0 外部计数模式void Timer0_Init(){ AUXR = 0x80; //定时器时钟1T模式 TMOD = 0x04; //设置定时器模式 TL0 = 0; //清除初始值 TH0 = 0; PT0 = 1; //T0中断优先级设为最高 TR0 = 1; //开始计数}void FreqCalc(){ static unsigned int freq; freq = (TH0 &lt;&lt; 8) + TL0; TL0 = 0; TH0 = 0; //下接数码管更新代码}//1ms @ 12.000MHzvoid Timer1_Interrupt() interrupt 3{ static unsigned int cnt; cnt++; if(cnt &gt;= 1000) { cnt = 0; FreqCalc(); }} 定数计时方案 定数计时方案是我认为非常好的一个方案。它的原理与定时计数不同，他是测量固定周期数的时间，比如测量10个周期的时间，得到每个周期，求倒数得到频率。实际应用当中，一般会取一个周期，也就是方波的两个上升沿之间的时间差，得到单周期的时间，求倒数即可。为了测量一个周期的时间，我们必须采用第二个定时器进行计时，因为Timer0必须用来做上升沿捕获，不能计时，就必须用另外一个定时器计时。这个方法计算的频率非常精确，可以达到小数级别。但是也有一定的限制。 首先，由于NE555产生的方波周期不太稳定，用这个方法测出来的频率是实时刷新的，一个数据对应一个周期，所以数据跳变会比较厉害。简单求平均就可以解决这个问题。 其次，这种方式所测量的频率有上下范围的限制。这个范围限制主要来自于单片机计时的精度限制。单片机内部计时，本质上还是计数，单片机对内部的高速时钟（12MHz）计数，因此一个数就代表112×106s\\frac{1}{12×10^6}s12×1061​s。这样就用计数的方式间接实现了计时。但是这样计时的最小时间间隔就是112s\\frac{1}{12}s121​s。所以，如果测量的频率非常高，一个周期的时间小于最小时间间隔，那么就无法计时了。据此算出的可测量最高频率为 fmax=1112×106=12MHzf_{max}=\\frac{1}{\\frac{1}{12×10^6}}=12MHz fmax​=12×1061​1​=12MHz 这个数显然是远大于我们板子上NE555能产生的最高频率的。 最低频率也是有限制的。定时器最大只能计65536次，也就是65536×112×106=0.0055s65536×\\frac{1}{12×10^6}=0.0055s65536×12×1061​=0.0055s，如果信号比较慢，一个周期的时间大于这个数，定时器就会满，就测不出来了。这个问题很好解决，如果定时器溢出，那么就把定时器清零，然后重新计，最后算时间的时候，加上溢出之前的0.0055s就可以了。溢出几次，就加几次时间。所以最低频率可以通过算法无限降低，相当于没有限制。 不过，还有一种方法我更推荐使用。STC15的定时器可以设置成1T或者12T模式，分别代表一个时钟记一次、十二个时钟记一次。刚才所有的计算都是基于1T模式计算的。如果用12T模式计算，那么得到的最大最小频率分别为： fmax=11212×106=1MHzfmin=655361212×106=15.26Hzf_{max} = \\frac{1}{\\frac{12}{12×10^6}}=1MHz\\\\ \\qquad\\\\ f_{min} = \\frac{65536}{\\frac{12}{12×10^6}}=15.26Hz fmax​=12×10612​1​=1MHzfmin​=12×10612​65536​=15.26Hz 这个范围非常完美的覆盖了NE555能够产生的频率范围，所以不需要算法上做什么优化，就可以测量出所有的频率。 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void Timer_Init(){ AUXR = 0x40; //定时器时钟1T模式 TMOD = 0x04; //设置定时器模式 TL0 = 0xFE; //两次脉冲 TH0 = 0xFF; TL1 = 0x50; //设置定时初始值 TH1 = 0xFB; //设置定时初始值 TL2 = 0; TH2 = 0; TF1 = 0; //清除TF1标志 TR1 = 1; //定时器1开始计时 ET1 = 1; ET0 = 1; TR0 = 1; PT0 = 1; //中断优先级最高}void FreqCalc(){ static unsigned char calltimes,i; static unsigned long int freqs[10]; calltimes++; if(calltimes &gt;= 20) { calltimes = 0; freqs[i] = 2000000 / freqValue; //频率计算公式 i++; if(i &gt; 9) { i=0; } freq = (freqs[0]+freqs[1]+freqs[2]+freqs[3]+freqs[4]+freqs[5]+freqs[6]+freqs[7]+freqs[8]+freqs[9]) / 10; //取平均 }}void FreqA(){ AUXR &amp;= 0xEF; //关闭Timer2 freqValue = (TH2 &lt;&lt; 8) + TL2; TH2 = 0; TL2 = 0; AUXR |= 0x10; //开启Timer2}void Timer0_Interrupt() interrupt 1{ FreqA();} 超声波测距 超声波是近两年才出的考题。难度不亚于频率检测。首先讲原理。 原理 超声波从发射到接收需要一定的时间，这段时间是超声波传播到障碍物再返回的时间，而超声波的速度就是声速340m/s，因此根据超声波反射回来的时间，就可以测量出板子距离障碍物的距离。 dist=vsonic×t2dist = v_{sonic} × \\frac{t}{2} dist=vsonic​×2t​ 单片机可以通过给P10一串脉冲信号来发送超声波 12345678910void DistDetectStart(){ for(i=0;i&lt;5;i++) { P10 = 1; Delay10us(); P10 = 0; Delay10us(); }} 如果CX20106接收到了间隔10us的脉冲，那么他会给单片机一个脉冲，代表接收到了正确的数据。这个脉冲可以被单片机P11口接收到。 因此，只要测量从发送一串脉冲信号，到P11口接收到脉冲信号的时间，就可以测量出ttt 计时方法 网上有很多方案都是用定时器实现的定时，但是这个方案不好，STC15这款MCU总共只有三个定时器，基础功能+频率检测正好全部用掉，没有寄存器给他用了。 一个比较简单的计时方法，是借助单片机内部的CCP模块。CCP——Capture/Compare/PWM模块，这个模块可以有三个功能，分别是捕获、比较、PWM。我们主要用他捕获的功能。下图是捕获功能的模式图 CL和CH是一个计数器的低八位和高八位，CCPn是外部输入管脚。如果CCPn管脚检测到了上升沿（或下降沿），则会触发一次捕获，把CH和CL的值存储到CCAPnH和CCAPnL里面，同时触发PCA中断。 因此，只要在发射超声波之后，开启CH和CL的计数，在PCA中断中，读取CCAPnH和CCAPnL的值，就可以知道从发射超声波到接收到超声波的时间。 n代表PCA通道的序号，我们使用PCA0。 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void PCA_Init(){ P_SW1 &amp;= 0xCF; CCON = 0; CMOD = 0x02; //SysClc / 2，使能中断 CL = 0; CH = 0; CCAPM0 = 0x11; //下降沿触发，使能中断}void DistDetectStart(){ unsigned char i; for(i=0;i&lt;5;i++) { P10 = 1; Delay10us(); P10 = 0; Delay10us(); } CL = 0; //清除计数值 CH = 0; CR = 1; //开始计时}void DistDetectReceive(){ unsigned char dat1, dat2; dat1 = CCAP0L; dat2 = CCAP0H; distValue = (dat2 &lt;&lt; 8) + dat1;}void PCA_Interrupt() interrupt 7{ if(CCF0) //判断是否是PCA0 { CCF0 = 0; //清标志位 DistDetectReceive(); CR = 0; //停止计时 }}void DistCalc(){ //距离（cm） = 速度 * 计数量 ÷ SysClk/2 ÷ 2 //实测，不需要除以2，我也不知道为啥 dist = distValue * 34000 / 6000000;} 结语 蓝桥杯这个比赛，实话讲，单片机的难度是很大的，我觉得要比嵌入式和EDA的难度要大。即使难度很大，他的参加人数也是电子类赛项中最多的。在这样的竞争压力下，想要打好，拿奖，训练的时候就要奔着满分的标准，对自己写的每一行代码都要非常熟悉，包括STC-ISP生成的代码，也一定要熟知每一行的含义和作用。再者，对单片机执行的逻辑也要非常熟悉，哪些外设哪些功能受哪个寄存器控制，就算背不下来也一定要有大概的印象，能够快速从芯片手册中查到。STC15的芯片手册很重要，很有用，对于单片机新手来说有很强的启蒙作用。","link":"/blog/2025/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"电赛","slug":"电赛","link":"/blog/tags/%E7%94%B5%E8%B5%9B/"},{"name":"电源","slug":"电源","link":"/blog/tags/%E7%94%B5%E6%BA%90/"},{"name":"CarSim","slug":"CarSim","link":"/blog/tags/CarSim/"},{"name":"STM32","slug":"STM32","link":"/blog/tags/STM32/"},{"name":"MAX30100","slug":"MAX30100","link":"/blog/tags/MAX30100/"},{"name":"USB","slug":"USB","link":"/blog/tags/USB/"},{"name":"音频","slug":"音频","link":"/blog/tags/%E9%9F%B3%E9%A2%91/"},{"name":"原理图","slug":"原理图","link":"/blog/tags/%E5%8E%9F%E7%90%86%E5%9B%BE/"},{"name":"PCB","slug":"PCB","link":"/blog/tags/PCB/"},{"name":"TCS","slug":"TCS","link":"/blog/tags/TCS/"},{"name":"Simulink","slug":"Simulink","link":"/blog/tags/Simulink/"},{"name":"仿真","slug":"仿真","link":"/blog/tags/%E4%BB%BF%E7%9C%9F/"},{"name":"Verilog","slug":"Verilog","link":"/blog/tags/Verilog/"},{"name":"Vivado","slug":"Vivado","link":"/blog/tags/Vivado/"},{"name":"WPF","slug":"WPF","link":"/blog/tags/WPF/"},{"name":"上位机","slug":"上位机","link":"/blog/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA/"},{"name":"雷达","slug":"雷达","link":"/blog/tags/%E9%9B%B7%E8%BE%BE/"},{"name":"u8g2","slug":"u8g2","link":"/blog/tags/u8g2/"},{"name":"电路","slug":"电路","link":"/blog/tags/%E7%94%B5%E8%B7%AF/"},{"name":"全志H3","slug":"全志H3","link":"/blog/tags/%E5%85%A8%E5%BF%97H3/"},{"name":"Linux","slug":"Linux","link":"/blog/tags/Linux/"},{"name":"ESP32","slug":"ESP32","link":"/blog/tags/ESP32/"},{"name":"大创","slug":"大创","link":"/blog/tags/%E5%A4%A7%E5%88%9B/"},{"name":"微机原理","slug":"微机原理","link":"/blog/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"汇编","slug":"汇编","link":"/blog/tags/%E6%B1%87%E7%BC%96/"},{"name":"51单片机","slug":"51单片机","link":"/blog/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"categories":[{"name":"项目","slug":"项目","link":"/blog/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"仿真","slug":"仿真","link":"/blog/categories/%E4%BB%BF%E7%9C%9F/"},{"name":"嵌入式","slug":"嵌入式","link":"/blog/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"硬件","slug":"硬件","link":"/blog/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"赛车","slug":"赛车","link":"/blog/categories/%E8%B5%9B%E8%BD%A6/"},{"name":"Verilog","slug":"Verilog","link":"/blog/categories/Verilog/"},{"name":"课业","slug":"课业","link":"/blog/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"软件","slug":"软件","link":"/blog/categories/%E8%BD%AF%E4%BB%B6/"},{"name":"网络","slug":"网络","link":"/blog/categories/%E7%BD%91%E7%BB%9C/"}],"pages":[{"title":"categories","text":"","link":"/blog/categories/index.html"}]}