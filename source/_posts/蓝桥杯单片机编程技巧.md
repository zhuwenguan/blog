---
title: 蓝桥杯单片机编程技巧
toc: true
date: 2025-03-27 13:57:10
categories: 嵌入式
tags:
  - 单片机
  - 嵌入式
---
## 前言
最近准备给班级介绍一下蓝桥杯单片机的比赛经验，把我去年自己研究的单片机比赛常用的编程技巧分享给大家，提升编程效率和效果。本篇文章同步介绍有关内容。
<!-- more -->
## 概述
蓝桥杯使用的单片机芯片型号是IAP15F2K61S2，属于STC15F系列，是STC15F系列的最高级别芯片。他还有一个姊妹芯片叫做STC15F2K60S2。两颗芯片几乎一模一样，最大的区别是前者支持单芯片在线仿真调试，后者不支持。所以，编程的时候，如果找不到IAP15F2K61S2的相关资料，可以直接用STC15F2K60S2的，他们的外设、内核都一样，代码是互通的。
蓝桥杯单片机主要考察的点有：IO口操作、I2C总线、One-Wire总线、计数器/定时器、芯片自定义总线、UART串口等。下表详细介绍这些知识点所对应的功能：

|   知识点    |  外围芯片   |    功能     |
| :------: | :-----: | :-------: |
|  IO口操作   |    \    |   按键扫描    |
|  IO口操作   | 译码器、锁存器 |   数码管显示   |
|  IO口操作   | 译码器、锁存器 |    LED    |
|  IO口操作   | 译码器、锁存器 |    蜂鸣器    |
|  IO口操作   | 译码器、锁存器 |    继电器    |
|  I2C总线   | PCF8591 |   电位器输入   |
|  I2C总线   | PCF8591 |   光敏电阻    |
|  I2C总线   | PCF8591 |   DAC输出   |
|  I2C总线   | AT24C02 |  EEPROM   |
| One-Wire | DS18B20 |   温度检测    |
|   计数器    |  NE555  |   频率检测    |
|   定时器    | CX20106 |   超声波测距   |
|   特殊总线   | DS1302  | 实时时钟(RTC) |
|  UART总线  |    \    |   上位机通信   |
近年的蓝桥杯题目，基本上会同时考察上面所有内容。而且不同的功能之间会有联系，比如、
## 频率检测
### 原理
Timer0
```c
void FreqA()
{
	AUXR &= 0xEF;	//关闭Timer2
	freqValue = (TH2 << 8) + TL2;
	TH2 = 0;
	TL2 = 0;
	AUXR |= 0x10;	//开启Timer2
}

void Timer0_Interrupt() interrupt 1
{
	FreqA();
}
```
## 代码框架
蓝桥杯的代码写起来还是比较困难的，主要是因为任务比较多，而51单片机的计算速度又慢得很，所以每个任务都会占用不少时间。时间与算力是直接相关的。如果一个任务计算完成需要很多时间，那么就代表他的计算需要很多的算力。所以优化代码主要就是优化时间。
这么多任务，代码怎么样安排呢？很多网上的模板都是这样写的：
```c
void main()
{
	初始化1();
	初始化2();
	...
	while(1)
	{
		任务1();
		任务2();
		...
		Delay1ms();
	}
}
```
我不建议使用`while(1)`作为程序的主循环。首先，任务执行的时间并不是固定的，有可能第一次执行这个任务的时候，所用时间比较短，第二次执行的时候用的时间比较长。那么就会导致第一次循环和第二次循环总时间不一样。这就容易导致数码管亮度不均匀之类的问题。其次，这样写，没有办法控制整个代码的运行速度。如果里面的任务执行速度很快，那么循环就很快，但是我们压根不需要这么快的速度；如果里面的任务执行很慢，就会发现整个系统都被拖慢了，我们无法定位具体是哪个任务拖慢的速度，也无法主动的干预。第三，由于这样写无法确定程序执行的时间，很难做出软件PWM或者LED定时闪烁之类的功能。
去年我参赛的时候，练习的所有代码都是用定时器中断作为主循环的。定时器中断是定时器溢出的标志，通过设置定时器的初值和自动重装载值，可以改变它溢出的时间。STC-ISP里面有专门的定时器计算工具，可以让定时器以任意时间间隔溢出，产生中断。比如，我常用的是用1ms的定时器中断。每次产生中断时，开始执行代码。比如这样：
```c
void main()
{
	初始化();
	while(1);
}
void Timer0_Interrupt() interrupt 1
{
	SegCalc();     //计算数码管显示值
	SegRefresh();  //刷新数码管
	KeyScan();     //按键扫描
	任务1();
	任务2();
}
```
而`main`函数里面只执行初始化代码。执行完之后直接`while(1);`无限等待。
这样写的好处就是，每一次进入中断的时候，都是上一次进入中断的1ms之后，时间非常准确。那么，数码管刷新、按键扫描等基本功能的刷新率都是稳稳的1kHz，不会因为其他代码执行导致刷新率变化，也就不会有闪烁、亮度不均等问题。
这样写也有一个问题，就是在中断当中执行的代码，时间不能太长。因为中断是1ms进入一次，如果中断代码执行时间大于1ms，那么上一次中断还没执行完，下一次中断又来了，整个程序就会被卡住，无限进入中断，永远执行不完代码。这就是我们认为的“跑飞了”。
所以这么写，一定要保证执行的时间不要大于1ms。那如果执行时间大于1ms咋办？最简单的办法就是，把定时器中断时间从1ms改成2ms，这样代码执行时间只要小于2ms就行了。不过这个数不是随便加的，51单片机定时器中断的时间理论最大值是
$$
t_{max}=65536×\frac{12}{12×10^6}=0.065536s=65.536ms
$$
这是在定时器设置为12T的情况下。
65ms的刷新速度其实是有点慢的，一般10ms我觉得是算是可以接受的最大时间了。这个时间很充裕的，如果你的代码无法在10ms内执行完的话，就该考虑一下优化代码了。
有同学会问了，如果我的代码不是1ms执行一次，而是1s执行一次，比如让LED闪烁。那这个定时器中断每次都是1ms，怎么办？
```c
1ms @ 12.000MHz
void Timer0_Interrupt() interrupt 1
{
	static unsigned int cnt;
	cnt++;
	if(cnt >= 1000)
	{
		cnt = 0;
		任务();
	}
}
```
这样写，任务就是1s执行一次了。这样写你会发现，1s内的大部分时间，代码只执行了cnt++，没有干别的，只有cnt到了1000的那一次，才会执行任务。这种代码我们成为非阻塞式代码，没有到它执行的时候，就跳过，不在它身上浪费时间，只有它需要执行的时候，才会执行。非阻塞式还包含执行的过程是否阻塞，这里不讨论了。
## 温度检测
之所以把温度检测放在定时器中断后面，就是因为，温度检测对定时器中断来说是个灾难。温度检测所用的DS18B20芯片是单总线芯片，单总线的特点就是慢。比如，它的初始化需要拉低460us，如果我们用1ms的定时器中断的话，一个初始化一半时间没了，这还没开始读取呢。后面读取的速度也是慢的离谱。如果把温度检测的任务加入定时器中断，那么100%会跑飞。
这该咋解决呢？首先，直接读取是不可能的了。其次，如果像刚才那样，加上一个`cnt`，一段时间执行一次，可以不可以呢？可以，但是不好。那样的话，视觉上会发现数码管有固定时间的卡顿，一会卡一下一会卡一下，整体流畅度还是不好，而且刷新率慢。我的做法是，分步执行。
```
void ReadTemp()
{
	static
	 step
}
```